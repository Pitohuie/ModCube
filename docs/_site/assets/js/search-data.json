{"0": {
    "doc": "API Documentation",
    "title": "API Documentation",
    "content": "This document provides comprehensive API documentation for the RS-ModCubes system, including ROS topics, services, messages, and Python APIs. The system implements advanced underwater robotics capabilities with modular architecture for autonomous underwater vehicles (AUVs). ",
    "url": "/ModCube.github.io/api/",
    
    "relUrl": "/api/"
  },"1": {
    "doc": "API Documentation",
    "title": "Table of Contents",
    "content": ". | ROS Topics | ROS Services | Message Definitions | Python APIs | C++ APIs | State Estimation APIs | Trajectory Generation APIs | Configuration Parameters | Plugin APIs | Examples | . ",
    "url": "/ModCube.github.io/api/#table-of-contents",
    
    "relUrl": "/api/#table-of-contents"
  },"2": {
    "doc": "API Documentation",
    "title": "ROS Topics",
    "content": "Control Topics . /modcube/controller_command . Type: modcube_msgs/ControllerCommand Description: High-level control commands for the vehicle Publisher: Mission planner, teleop nodes Subscriber: PID controller . # Message structure header: stamp: time frame_id: string mode: int32 # Control mode (1=position, 2=velocity, 3=acceleration) setpoint: position: # Target position (mode 1) x: float64 y: float64 z: float64 orientation: # Target orientation (quaternion) x: float64 y: float64 z: float64 w: float64 linear: # Target linear velocity (mode 2) x: float64 y: float64 z: float64 angular: # Target angular velocity (mode 2) x: float64 y: float64 z: float64 . /modcube/thrust_command . Type: modcube_msgs/ThrusterCommand Description: Direct thruster control commands Publisher: Thruster manager, controllers Subscriber: Hardware drivers . # Message structure header: stamp: time frame_id: string thrusters: float64[14] # Thrust values for 14 thrusters (-1.0 to 1.0) . State Topics . /modcube/nav_state . Type: modcube_msgs/NavState Description: Current navigation state of the vehicle Publisher: State estimator Subscriber: Controllers, mission planner . # Message structure header: stamp: time frame_id: string pose: pose: position: x: float64 y: float64 z: float64 orientation: x: float64 y: float64 z: float64 w: float64 covariance: float64[36] twist: twist: linear: x: float64 y: float64 z: float64 angular: x: float64 y: float64 z: float64 covariance: float64[36] . Sensor Topics . /modcube/imu/data . Type: sensor_msgs/Imu Description: IMU sensor data Publisher: IMU driver Subscriber: State estimator . /modcube/dvl/data . Type: modcube_msgs/DVLData Description: DVL sensor data Publisher: DVL driver Subscriber: State estimator . # DVLData message structure header: stamp: time frame_id: string velocity: x: float64 y: float64 z: float64 altitude: float64 beam_ranges: float64[4] beam_velocities: float64[4] status: int32 . /modcube/depth . Type: modcube_msgs/FluidDepth Description: Depth sensor data Publisher: Depth sensor driver Subscriber: State estimator . Mission Topics . /modcube/mission_state . Type: modcube_msgs/MissionState Description: Current mission status Publisher: Mission manager Subscriber: Mission monitor, GUI . /modcube/alarms . Type: modcube_msgs/Alarm Description: System alarms and warnings Publisher: Various nodes Subscriber: Mission manager, safety monitor . Trajectory and Path Planning Topics . /modcube/trajectory/path . Type: nav_msgs/Path Description: Planned trajectory path for visualization Publisher: PID planner, trajectory generator Subscriber: RViz, mission monitor . /modcube/trajectory/target . Type: geometry_msgs/PoseStamped Description: Current trajectory target pose Publisher: Trajectory generator Subscriber: PID planner, controllers . /modcube/trajectory/request . Type: modcube_msgs/GetTrajectoryRequest Description: Request for trajectory generation Publisher: Mission planner Subscriber: Trajectory generator . Debug and Monitoring Topics . /modcube/debug/pid_output . Type: modcube_msgs/PIDDebug Description: PID controller debug information Publisher: PID planner Subscriber: Debug monitor, tuning tools . /modcube/debug/ekf_state . Type: modcube_msgs/EKFDebug Description: Extended Kalman Filter internal state Publisher: State estimator Subscriber: Debug monitor, analysis tools . /modcube/debug/thruster_allocation . Type: modcube_msgs/ThrusterAllocation Description: Thruster allocation matrix output Publisher: Thruster manager Subscriber: Debug monitor, performance analysis . ",
    "url": "/ModCube.github.io/api/#ros-topics",
    
    "relUrl": "/api/#ros-topics"
  },"3": {
    "doc": "API Documentation",
    "title": "ROS Services",
    "content": "Control Services . /modcube/set_pid_params . Type: modcube_msgs/SetPIDParams Description: Set PID controller parameters . # Request position_gains: p: float64[3] # [x, y, z] i: float64[3] d: float64[3] orientation_gains: p: float64[3] # [roll, pitch, yaw] i: float64[3] d: float64[3] # Response success: bool message: string . /modcube/get_pid_params . Type: modcube_msgs/GetPIDParams Description: Get current PID controller parameters . /modcube/set_thruster_config . Type: modcube_msgs/SetThrusterManagerConfig Description: Configure thruster manager . # Request thruster_ids: int32[] max_thrust: float64[] thruster_topic_prefix: string thruster_topic_suffix: string thruster_frame_base: string max_thrust_pc: float64 # Response success: bool message: string . Mission Services . /modcube/mission_control . Type: modcube_msgs/MissionControl Description: Control mission execution . # Request command: string # 'start', 'stop', 'pause', 'resume' mission_type: string # Mission type identifier parameters: string[] # Mission-specific parameters # Response success: bool message: string mission_id: string . State Estimation Services . /modcube/state_estimator/reset . Type: modcube_msgs/ResetStateEstimator Description: Reset state estimator with optional initial state . # Request initial_pose: position: {x: float64, y: float64, z: float64} orientation: {x: float64, y: float64, z: float64, w: float64} initial_velocity: linear: {x: float64, y: float64, z: float64} angular: {x: float64, y: float64, z: float64} reset_covariance: bool # Response success: bool message: string . /modcube/state_estimator/set_sensor_config . Type: modcube_msgs/SetSensorConfig Description: Configure sensor parameters for state estimation . Trajectory Generation Services . /modcube/trajectory/generate . Type: modcube_msgs/GenerateTrajectory Description: Generate optimal trajectory between waypoints . # Request waypoints: geometry_msgs/PoseStamped[] start_velocity: geometry_msgs/Twist end_velocity: geometry_msgs/Twist aggressiveness: float64 # 0.0 to 1.0 max_velocity: float64 max_acceleration: float64 # Response success: bool trajectory: nav_msgs/Path total_time: float64 total_distance: float64 average_speed: float64 . /modcube/trajectory/get_target . Type: modcube_msgs/GetTrajectoryTarget Description: Get current trajectory target at specified time . Dynamic Parameter Services . /modcube/tune_pid_planner . Type: modcube_msgs/TunePIDPlanner Description: Dynamically tune PID planner parameters . # Request axis: string # 'x', 'y', 'z', 'roll', 'pitch', 'yaw' kp: float64 ki: float64 kd: float64 tau: float64 limit: float64 # Response success: bool message: string . /modcube/tune_dynamics . Type: modcube_msgs/TuneDynamics Description: Tune vehicle dynamics parameters . # Request mass: float64 volume: float64 water_density: float64 center_of_gravity: geometry_msgs/Vector3 center_of_buoyancy: geometry_msgs/Vector3 moments_of_inertia: float64[6] # [Ixx, Iyy, Izz, Ixy, Ixz, Iyz] linear_damping: float64[6] quadratic_damping: float64[6] added_mass: float64[36] # 6x6 matrix # Response success: bool message: string . Diagnostic Services . /modcube/get_system_status . Type: modcube_msgs/GetSystemStatus Description: Get comprehensive system status . /modcube/test_thrusters . Type: modcube_msgs/TestThrusters Description: Test individual thrusters . /modcube/calibrate_sensors . Type: modcube_msgs/CalibrateSensors Description: Perform sensor calibration procedures . ",
    "url": "/ModCube.github.io/api/#ros-services",
    
    "relUrl": "/api/#ros-services"
  },"4": {
    "doc": "API Documentation",
    "title": "Message Definitions",
    "content": "Core Messages . modcube_msgs/ControllerCommand . std_msgs/Header header int32 mode # 1=position, 2=velocity, 3=acceleration geometry_msgs/Pose setpoint_pose geometry_msgs/Twist setpoint_twist geometry_msgs/Accel setpoint_accel bool enable_position_hold bool enable_depth_hold bool enable_heading_hold float64 timeout # Command timeout in seconds . modcube_msgs/NavigationState . std_msgs/Header header geometry_msgs/PoseWithCovariance pose geometry_msgs/TwistWithCovariance twist geometry_msgs/AccelWithCovariance accel geometry_msgs/Vector3 euler_angles # [roll, pitch, yaw] geometry_msgs/Vector3 euler_rates # [roll_rate, pitch_rate, yaw_rate] geometry_msgs/Vector3 euler_accels # [roll_accel, pitch_accel, yaw_accel] float64 depth float64 altitude bool is_valid float64 timestamp . modcube_msgs/ThrusterCommand . std_msgs/Header header float64[14] thrusters # Normalized thrust values [-1.0, 1.0] float64[14] thrust_forces # Actual thrust forces in Newtons bool emergency_stop float64 max_thrust_percentage # Global thrust scaling [0.0, 1.0] . Sensor Messages . modcube_msgs/DVLData . std_msgs/Header header geometry_msgs/Vector3 velocity float64 altitude float64[4] beam_ranges float64[4] beam_velocities int32 status . modcube_msgs/FluidDepth . std_msgs/Header header float64 depth float64 pressure float64 temperature . modcube_msgs/SonarPulse . std_msgs/Header header float64 range float64 intensity float64 angle . Detection Messages . modcube_msgs/AprilTagDetection . std_msgs/Header header int32 id geometry_msgs/PoseWithCovariance pose float64 size float64 confidence . modcube_msgs/GateDetection . std_msgs/Header header geometry_msgs/Point[] corners float64 width float64 height float64 confidence . System Messages . modcube_msgs/Alarm . std_msgs/Header header string alarm_name int32 severity # 0=info, 1=warning, 2=error, 3=critical string description bool active . modcube_msgs/BatteryStatus . std_msgs/Header header float64 voltage float64 current float64 charge_percentage float64 temperature int32 status # 0=unknown, 1=charging, 2=discharging, 3=full . Debug and Analysis Messages . modcube_msgs/PIDDebug . std_msgs/Header header string axis # 'x', 'y', 'z', 'roll', 'pitch', 'yaw' float64 setpoint float64 process_variable float64 error float64 error_integral float64 error_derivative float64 proportional_term float64 integral_term float64 derivative_term float64 output float64 output_limited float64 kp float64 ki float64 kd float64 tau float64 limit . modcube_msgs/EKFDebug . std_msgs/Header header float64[15] state_vector # [pos_x, pos_y, pos_z, vel_x, vel_y, vel_z, # acc_x, acc_y, acc_z, roll, pitch, yaw, # ang_vel_x, ang_vel_y, ang_vel_z] float64[225] covariance # 15x15 covariance matrix (row-major) float64[15] innovation # Innovation vector float64[225] innovation_cov # Innovation covariance string last_update_sensor # Last sensor that updated the filter float64 mahalanobis_distance # Mahalanobis distance for outlier detection bool is_converged . modcube_msgs/ThrusterAllocation . std_msgs/Header header geometry_msgs/Wrench desired_wrench float64[14] allocated_thrusts float64[6] achieved_wrench # [Fx, Fy, Fz, Tx, Ty, Tz] float64 allocation_error # Norm of (desired - achieved) float64[14] saturation_flags # 1.0 if thruster is saturated, 0.0 otherwise . Trajectory Messages . modcube_msgs/TrajectoryPoint . float64 time_from_start geometry_msgs/Pose pose geometry_msgs/Twist velocity geometry_msgs/Accel acceleration . modcube_msgs/OptimalTrajectory . std_msgs/Header header modcube_msgs/TrajectoryPoint[] points float64 total_time float64 total_distance float64 average_speed float64 max_velocity float64 max_acceleration float64 aggressiveness string optimization_method # 'minimum_snap', 'minimum_jerk', etc. ",
    "url": "/ModCube.github.io/api/#message-definitions",
    
    "relUrl": "/api/#message-definitions"
  },"5": {
    "doc": "API Documentation",
    "title": "Python APIs",
    "content": "Controller API . modcube_common.controllers.PIDController . class PIDController: def __init__(self, namespace='/modcube'): \"\"\"Initialize PID controller. Args: namespace (str): ROS namespace for topics and services \"\"\" def set_gains(self, pos_gains, orient_gains): \"\"\"Set PID gains. Args: pos_gains (dict): Position gains {'p': [x,y,z], 'i': [x,y,z], 'd': [x,y,z]} orient_gains (dict): Orientation gains {'p': [r,p,y], 'i': [r,p,y], 'd': [r,p,y]} Returns: bool: Success status \"\"\" def compute_wrench(self, current_state, desired_state): \"\"\"Compute control wrench. Args: current_state (NavState): Current vehicle state desired_state (ControllerCommand): Desired state Returns: geometry_msgs/Wrench: Control wrench \"\"\" def enable(self): \"\"\"Enable controller.\"\"\" def disable(self): \"\"\"Disable controller.\"\"\" . Example Usage . import rospy from modcube_common.controllers import PIDController from modcube_msgs.msg import ControllerCommand from geometry_msgs.msg import Point, Quaternion # Initialize controller controller = PIDController(namespace='/modcube') # Set gains pos_gains = {'p': [10.0, 10.0, 10.0], 'i': [0.1, 0.1, 0.1], 'd': [5.0, 5.0, 5.0]} orient_gains = {'p': [20.0, 20.0, 20.0], 'i': [0.2, 0.2, 0.2], 'd': [8.0, 8.0, 8.0]} controller.set_gains(pos_gains, orient_gains) # Enable controller controller.enable() # Send command cmd = ControllerCommand() cmd.mode = 1 # Position control cmd.setpoint.position = Point(1.0, 0.0, -1.0) cmd.setpoint.orientation = Quaternion(0, 0, 0, 1) controller.send_command(cmd) . Motion Client API . modcube_common.motion.MotionClient . class MotionClient: def __init__(self, namespace='/modcube'): \"\"\"Initialize motion client.\"\"\" def goto_position(self, x, y, z, timeout=30.0): \"\"\"Move to specified position. Args: x, y, z (float): Target position timeout (float): Maximum time to reach target Returns: bool: Success status \"\"\" def goto_pose(self, pose, timeout=30.0): \"\"\"Move to specified pose. Args: pose (geometry_msgs/Pose): Target pose timeout (float): Maximum time to reach target Returns: bool: Success status \"\"\" def follow_trajectory(self, trajectory): \"\"\"Follow a trajectory. Args: trajectory (nav_msgs/Path): Trajectory to follow Returns: bool: Success status \"\"\" def stop(self): \"\"\"Stop all motion.\"\"\" def get_current_pose(self): \"\"\"Get current vehicle pose. Returns: geometry_msgs/Pose: Current pose \"\"\" . Mission Manager API . modcube_mission.MissionManager . class MissionManager: def __init__(self): \"\"\"Initialize mission manager.\"\"\" def start_mission(self, mission_type, parameters=None): \"\"\"Start a mission. Args: mission_type (str): Type of mission parameters (dict): Mission parameters Returns: str: Mission ID \"\"\" def stop_mission(self, mission_id): \"\"\"Stop a running mission. Args: mission_id (str): Mission ID to stop Returns: bool: Success status \"\"\" def get_mission_status(self, mission_id): \"\"\"Get mission status. Args: mission_id (str): Mission ID Returns: dict: Mission status information \"\"\" def register_mission_type(self, mission_type, mission_class): \"\"\"Register a new mission type. Args: mission_type (str): Mission type identifier mission_class (class): Mission implementation class \"\"\" . State Estimation API . modcube_common.state_estimation.StateEstimator . class StateEstimator: def __init__(self, sensors=None): \"\"\"Initialize state estimator. Args: sensors (list): List of sensor configurations \"\"\" def add_sensor(self, sensor_type, topic, frame_id): \"\"\"Add a sensor to the estimator. Args: sensor_type (str): Type of sensor ('imu', 'dvl', 'depth', etc.) topic (str): ROS topic for sensor data frame_id (str): Sensor frame ID \"\"\" def get_state(self): \"\"\"Get current estimated state. Returns: NavState: Current navigation state \"\"\" def reset_state(self, initial_state=None): \"\"\"Reset estimator state. Args: initial_state (NavState): Initial state (optional) \"\"\" ## C++ APIs ### Extended Kalman Filter API #### `modcube_common::Ekf` ```cpp #include &lt;modcube_common/ekf.h&gt; namespace modcube_common { class Ekf { public: /** * @brief Constructor */ Ekf(); /** * @brief Destructor */ ~Ekf(); /** * @brief Set DVL offset from vehicle center * @param offset DVL offset vector [x, y, z] */ void setDvlOffset(const Eigen::Vector3d&amp; offset); /** * @brief Set process noise covariance * @param cov Process noise covariance matrix (15x15) */ void setProcessCovariance(const Eigen::MatrixXd&amp; cov); /** * @brief Get current state vector * @return State vector [pos, vel, acc, euler, ang_vel] */ Eigen::VectorXd getState() const; /** * @brief Set state vector * @param state State vector (15x1) */ void setState(const Eigen::VectorXd&amp; state); /** * @brief Get state covariance matrix * @return Covariance matrix (15x15) */ Eigen::MatrixXd getCovariance() const; /** * @brief Set state covariance matrix * @param cov Covariance matrix (15x15) */ void setCovariance(const Eigen::MatrixXd&amp; cov); /** * @brief Process IMU measurement * @param imu_data IMU sensor data * @param dt Time step */ void handleImuMeasurement(const sensor_msgs::Imu&amp; imu_data, double dt); /** * @brief Process DVL measurement * @param dvl_data DVL sensor data * @param dt Time step */ void handleDvlMeasurement(const modcube_msgs::DVLData&amp; dvl_data, double dt); /** * @brief Process depth measurement * @param depth_data Depth sensor data * @param dt Time step */ void handleDepthMeasurement(const modcube_msgs::FluidDepth&amp; depth_data, double dt); private: /** * @brief Prediction step of EKF * @param dt Time step */ void predict(double dt); /** * @brief Update step of EKF * @param measurement Measurement vector * @param measurement_cov Measurement covariance * @param H Measurement Jacobian */ void update(const Eigen::VectorXd&amp; measurement, const Eigen::MatrixXd&amp; measurement_cov, const Eigen::MatrixXd&amp; H); /** * @brief Extrapolate state forward in time * @param state Current state * @param dt Time step * @return Extrapolated state */ Eigen::VectorXd extrapolateState(const Eigen::VectorXd&amp; state, double dt); /** * @brief Extrapolate covariance forward in time * @param cov Current covariance * @param F State transition Jacobian * @param Q Process noise covariance * @return Extrapolated covariance */ Eigen::MatrixXd extrapolateCovariance(const Eigen::MatrixXd&amp; cov, const Eigen::MatrixXd&amp; F, const Eigen::MatrixXd&amp; Q); /** * @brief Wrap angles to [-pi, pi] * @param angle Input angle * @return Wrapped angle */ double wrapAngle(double angle); /** * @brief Calculate state transition Jacobian * @param state Current state * @param dt Time step * @return Jacobian matrix */ Eigen::MatrixXd calculateStateJacobian(const Eigen::VectorXd&amp; state, double dt); // State vector: [pos_x, pos_y, pos_z, vel_x, vel_y, vel_z, // acc_x, acc_y, acc_z, roll, pitch, yaw, // ang_vel_x, ang_vel_y, ang_vel_z] Eigen::VectorXd state_; // 15x1 state vector Eigen::MatrixXd covariance_; // 15x15 covariance matrix Eigen::MatrixXd process_cov_; // 15x15 process noise covariance Eigen::Vector3d dvl_offset_; // DVL offset from vehicle center bool is_initialized_; double last_update_time_; }; } // namespace modcube_common . State Estimator API . modcube_common::StateEstimator . #include &lt;modcube_common/state_estimator.h&gt; namespace modcube_common { class StateEstimator { public: /** * @brief Constructor * @param nh ROS node handle */ explicit StateEstimator(ros::NodeHandle&amp; nh); /** * @brief Destructor */ ~StateEstimator(); /** * @brief Initialize state estimator * @return Success status */ bool initialize(); /** * @brief Start state estimation */ void start(); /** * @brief Stop state estimation */ void stop(); /** * @brief Get current navigation state * @return Current navigation state */ modcube_msgs::NavigationState getCurrentState() const; private: /** * @brief IMU callback * @param msg IMU message */ void imuCallback(const sensor_msgs::Imu::ConstPtr&amp; msg); /** * @brief DVL callback * @param msg DVL message */ void dvlCallback(const modcube_msgs::DVLData::ConstPtr&amp; msg); /** * @brief Depth callback * @param msg Depth message */ void depthCallback(const modcube_msgs::FluidDepth::ConstPtr&amp; msg); /** * @brief Publish navigation state */ void publishState(); /** * @brief Load configuration parameters * @return Success status */ bool loadConfig(); ros::NodeHandle nh_; // Subscribers ros::Subscriber imu_sub_; ros::Subscriber dvl_sub_; ros::Subscriber depth_sub_; // Publishers ros::Publisher nav_state_pub_; ros::Publisher debug_pub_; // Services ros::ServiceServer reset_service_; ros::ServiceServer config_service_; // EKF instance std::unique_ptr&lt;Ekf&gt; ekf_; // Configuration double publish_rate_; std::string base_frame_; std::string world_frame_; // Sensor delays and covariances double imu_delay_; double dvl_delay_; double depth_delay_; Eigen::MatrixXd imu_cov_; Eigen::MatrixXd dvl_cov_; Eigen::MatrixXd depth_cov_; // State bool is_initialized_; bool is_running_; mutable std::mutex state_mutex_; }; } // namespace modcube_common . ",
    "url": "/ModCube.github.io/api/#python-apis",
    
    "relUrl": "/api/#python-apis"
  },"6": {
    "doc": "API Documentation",
    "title": "State Estimation APIs",
    "content": "Multi-Sensor Fusion . modcube_common.state_estimation.ExtendedKalmanFilter . class ExtendedKalmanFilter: \"\"\"Extended Kalman Filter for underwater vehicle state estimation.\"\"\" def __init__(self, initial_state=None, initial_covariance=None): \"\"\"Initialize EKF with optional initial conditions. Args: initial_state (np.ndarray): Initial 15-element state vector initial_covariance (np.ndarray): Initial 15x15 covariance matrix \"\"\" def predict(self, dt, control_input=None): \"\"\"Prediction step of EKF. Args: dt (float): Time step in seconds control_input (np.ndarray): Optional control input vector \"\"\" def update_imu(self, acceleration, angular_velocity, orientation=None): \"\"\"Update with IMU measurement. Args: acceleration (np.ndarray): Linear acceleration [ax, ay, az] angular_velocity (np.ndarray): Angular velocity [wx, wy, wz] orientation (np.ndarray): Optional orientation quaternion [x, y, z, w] \"\"\" def update_dvl(self, velocity, altitude=None): \"\"\"Update with DVL measurement. Args: velocity (np.ndarray): Velocity measurement [vx, vy, vz] altitude (float): Optional altitude measurement \"\"\" def update_depth(self, depth): \"\"\"Update with depth measurement. Args: depth (float): Depth measurement in meters \"\"\" def update_position(self, position, covariance=None): \"\"\"Update with absolute position measurement. Args: position (np.ndarray): Position measurement [x, y, z] covariance (np.ndarray): Optional measurement covariance \"\"\" def get_state(self): \"\"\"Get current state estimate. Returns: dict: State dictionary with position, velocity, acceleration, orientation \"\"\" def get_covariance(self): \"\"\"Get current state covariance. Returns: np.ndarray: 15x15 covariance matrix \"\"\" def reset(self, state=None, covariance=None): \"\"\"Reset filter state. Args: state (np.ndarray): Optional new state vector covariance (np.ndarray): Optional new covariance matrix \"\"\" . modcube_common.state_estimation.VisualOdometry . class VisualOdometry: \"\"\"Visual odometry for underwater environments.\"\"\" def __init__(self, camera_params, feature_detector='ORB'): \"\"\"Initialize visual odometry. Args: camera_params (dict): Camera calibration parameters feature_detector (str): Feature detector type ('ORB', 'SIFT', 'SURF') \"\"\" def process_frame(self, image, timestamp): \"\"\"Process new camera frame. Args: image (np.ndarray): Input image timestamp (float): Image timestamp Returns: dict: Pose estimate and confidence \"\"\" def get_pose_estimate(self): \"\"\"Get current pose estimate. Returns: geometry_msgs/PoseWithCovariance: Current pose estimate \"\"\" def reset_tracking(self): \"\"\"Reset visual tracking.\"\"\" . ",
    "url": "/ModCube.github.io/api/#state-estimation-apis",
    
    "relUrl": "/api/#state-estimation-apis"
  },"7": {
    "doc": "API Documentation",
    "title": "Trajectory Generation APIs",
    "content": "Optimal Trajectory Planning . modcube_common.trajectory.DroneTrajectory . class DroneTrajectory: \"\"\"Optimal spline trajectory generator for underwater vehicles.\"\"\" def __init__(self): \"\"\"Initialize trajectory generator.\"\"\" def solve(self, waypoints, aggressiveness=0.5, start_vel=None, end_vel=None): \"\"\"Generate optimal trajectory through waypoints. Args: waypoints (list): List of TrajectoryWaypoint objects aggressiveness (float): Trajectory aggressiveness [0.0, 1.0] start_vel (np.ndarray): Initial velocity [vx, vy, vz] end_vel (np.ndarray): Final velocity [vx, vy, vz] Returns: bool: Success status \"\"\" def evaluate(self, t): \"\"\"Evaluate trajectory at given time. Args: t (float): Time from trajectory start Returns: dict: Position, velocity, acceleration at time t \"\"\" def get_position(self, t): \"\"\"Get position at time t. Args: t (float): Time from trajectory start Returns: np.ndarray: Position [x, y, z] \"\"\" def get_velocity(self, t): \"\"\"Get velocity at time t. Args: t (float): Time from trajectory start Returns: np.ndarray: Velocity [vx, vy, vz] \"\"\" def get_acceleration(self, t): \"\"\"Get acceleration at time t. Args: t (float): Time from trajectory start Returns: np.ndarray: Acceleration [ax, ay, az] \"\"\" def to_path_msg(self, dt=0.1): \"\"\"Convert trajectory to ROS Path message. Args: dt (float): Time step for path discretization Returns: nav_msgs/Path: ROS path message \"\"\" def get_total_time(self): \"\"\"Get total trajectory time. Returns: float: Total time in seconds \"\"\" def get_total_distance(self): \"\"\"Get total trajectory distance. Returns: float: Total distance in meters \"\"\" def get_average_speed(self): \"\"\"Get average trajectory speed. Returns: float: Average speed in m/s \"\"\" . modcube_common.trajectory.TrajectoryWaypoint . class TrajectoryWaypoint: \"\"\"Waypoint for trajectory generation.\"\"\" def __init__(self, position, orientation=None, constraints=None): \"\"\"Initialize waypoint. Args: position (np.ndarray): Waypoint position [x, y, z] orientation (np.ndarray): Optional orientation quaternion [x, y, z, w] constraints (dict): Optional velocity/acceleration constraints \"\"\" def set_velocity_constraint(self, velocity): \"\"\"Set velocity constraint at waypoint. Args: velocity (np.ndarray): Velocity constraint [vx, vy, vz] \"\"\" def set_acceleration_constraint(self, acceleration): \"\"\"Set acceleration constraint at waypoint. Args: acceleration (np.ndarray): Acceleration constraint [ax, ay, az] \"\"\" . Minimum Snap Trajectory . modcube_common.trajectory.OptimalTrajectory . class OptimalTrajectory: \"\"\"Minimum snap trajectory optimization.\"\"\" def __init__(self, dimension=3): \"\"\"Initialize trajectory optimizer. Args: dimension (int): Spatial dimension (3 for 3D trajectories) \"\"\" def generate_trajectory(self, waypoints, time_allocation, derivative_order=4, continuity_order=3): \"\"\"Generate minimum snap trajectory. Args: waypoints (list): List of waypoint positions time_allocation (list): Time allocation between waypoints derivative_order (int): Order of derivative to minimize (4 for snap) continuity_order (int): Continuity order at waypoints Returns: dict: Trajectory coefficients and metadata \"\"\" def evaluate_polynomial(self, coefficients, t, derivative=0): \"\"\"Evaluate polynomial trajectory. Args: coefficients (np.ndarray): Polynomial coefficients t (float): Time parameter derivative (int): Derivative order (0=position, 1=velocity, etc.) Returns: np.ndarray: Evaluated trajectory point \"\"\" . Path Planning and Navigation . modcube_common.navigation.PathPlanner . class PathPlanner: \"\"\"A* and RRT* path planning for underwater environments.\"\"\" def __init__(self, occupancy_map=None, planning_algorithm='A*'): \"\"\"Initialize path planner. Args: occupancy_map (OccupancyGrid): Optional occupancy grid map planning_algorithm (str): Planning algorithm ('A*', 'RRT*', 'PRM') \"\"\" def plan_path(self, start, goal, constraints=None): \"\"\"Plan path from start to goal. Args: start (np.ndarray): Start position [x, y, z] goal (np.ndarray): Goal position [x, y, z] constraints (dict): Optional planning constraints Returns: list: List of waypoints forming the path \"\"\" def update_map(self, occupancy_grid): \"\"\"Update occupancy map. Args: occupancy_grid (nav_msgs/OccupancyGrid): New occupancy grid \"\"\" def set_vehicle_constraints(self, max_velocity, max_acceleration, turning_radius): \"\"\"Set vehicle dynamic constraints. Args: max_velocity (float): Maximum velocity in m/s max_acceleration (float): Maximum acceleration in m/s² turning_radius (float): Minimum turning radius in meters \"\"\" . modcube_common.navigation.ObstacleAvoidance . class ObstacleAvoidance: \"\"\"Real-time obstacle avoidance using potential fields.\"\"\" def __init__(self, safety_distance=2.0, max_avoidance_force=5.0): \"\"\"Initialize obstacle avoidance. Args: safety_distance (float): Minimum distance to obstacles in meters max_avoidance_force (float): Maximum avoidance force magnitude \"\"\" def compute_avoidance_force(self, current_position, obstacles, target_velocity): \"\"\"Compute obstacle avoidance force. Args: current_position (np.ndarray): Current vehicle position [x, y, z] obstacles (list): List of obstacle positions and sizes target_velocity (np.ndarray): Desired velocity [vx, vy, vz] Returns: np.ndarray: Avoidance force vector [fx, fy, fz] \"\"\" def update_obstacles(self, sensor_data): \"\"\"Update obstacle map from sensor data. Args: sensor_data (dict): Sensor data including sonar, lidar, camera \"\"\" . ",
    "url": "/ModCube.github.io/api/#trajectory-generation-apis",
    
    "relUrl": "/api/#trajectory-generation-apis"
  },"8": {
    "doc": "API Documentation",
    "title": "Advanced Configuration Parameters",
    "content": "Controller Parameters . # PID Controller controller: position_gains: p: [10.0, 10.0, 10.0] # Proportional gains [x, y, z] i: [0.1, 0.1, 0.1] # Integral gains [x, y, z] d: [5.0, 5.0, 5.0] # Derivative gains [x, y, z] orientation_gains: p: [20.0, 20.0, 20.0] # Proportional gains [roll, pitch, yaw] i: [0.2, 0.2, 0.2] # Integral gains [roll, pitch, yaw] d: [8.0, 8.0, 8.0] # Derivative gains [roll, pitch, yaw] max_thrust: 100.0 # Maximum thrust (N) control_frequency: 100 # Control loop frequency (Hz) # Advanced controller settings adaptive_gains: enabled: true adaptation_rate: 0.01 min_gain_factor: 0.1 max_gain_factor: 5.0 anti_windup: enabled: true max_integral: [10.0, 10.0, 10.0, 5.0, 5.0, 5.0] feedforward: enabled: true velocity_ff: [0.8, 0.8, 0.8] acceleration_ff: [0.2, 0.2, 0.2] saturation_limits: position_error_max: [5.0, 5.0, 5.0] # Maximum position error (m) velocity_max: [2.0, 2.0, 2.0] # Maximum velocity (m/s) angular_velocity_max: [1.0, 1.0, 1.0] # Maximum angular velocity (rad/s) . Thruster Manager Parameters . # Thruster Manager thruster_manager: thrusters: - id: 0 frame: \"thruster_0\" max_thrust: 50.0 topic: \"/modcube/thrusters/0/input\" - id: 1 frame: \"thruster_1\" max_thrust: 50.0 topic: \"/modcube/thrusters/1/input\" # ... additional thrusters allocation_matrix: \"tam_14_thrusters.yaml\" update_rate: 50 # Hz . Sensor Parameters . # IMU Configuration imu: frame_id: \"imu_link\" topic: \"/modcube/imu/data\" frequency: 100 orientation_covariance: [0.01, 0.01, 0.01] angular_velocity_covariance: [0.001, 0.001, 0.001] linear_acceleration_covariance: [0.01, 0.01, 0.01] bias_estimation: enabled: true gyro_bias_std: 0.001 accel_bias_std: 0.01 calibration: auto_calibrate: true calibration_time: 30.0 # seconds # DVL Configuration dvl: frame_id: \"dvl_link\" topic: \"/modcube/dvl/data\" frequency: 10 velocity_covariance: [0.01, 0.01, 0.01] altitude_covariance: 0.1 beam_configuration: num_beams: 4 beam_angle: 30.0 # degrees max_range: 100.0 # meters outlier_rejection: enabled: true velocity_threshold: 5.0 # m/s altitude_threshold: 200.0 # m # Depth Sensor Configuration depth_sensor: frame_id: \"depth_link\" topic: \"/modcube/depth\" frequency: 20 depth_covariance: 0.01 pressure_to_depth: water_density: 1025.0 # kg/m³ gravity: 9.81 # m/s² atmospheric_pressure: 101325.0 # Pa filtering: enabled: true filter_type: \"low_pass\" cutoff_frequency: 5.0 # Hz # Camera Configuration camera: frame_id: \"camera_link\" image_topic: \"/modcube/camera/image_raw\" info_topic: \"/modcube/camera/camera_info\" frequency: 30 resolution: [1920, 1080] field_of_view: [90.0, 60.0] # [horizontal, vertical] degrees exposure: auto_exposure: true exposure_time: 0.033 # seconds white_balance: auto_white_balance: true color_temperature: 5000 # K # Sonar Configuration sonar: frame_id: \"sonar_link\" topic: \"/modcube/sonar/data\" frequency: 10 range_min: 0.5 # meters range_max: 50.0 # meters field_of_view: 120.0 # degrees resolution: 1.0 # degrees . ",
    "url": "/ModCube.github.io/api/#advanced-configuration-parameters",
    
    "relUrl": "/api/#advanced-configuration-parameters"
  },"9": {
    "doc": "API Documentation",
    "title": "Plugin APIs",
    "content": "Gazebo Plugin API . Custom Thruster Plugin . // custom_thruster_plugin.h #include &lt;gazebo/gazebo.hh&gt; #include &lt;gazebo/physics/physics.hh&gt; #include &lt;ros/ros.h&gt; #include &lt;modcube_msgs/ThrusterCommand.h&gt; namespace gazebo { class CustomThrusterPlugin : public ModelPlugin { public: CustomThrusterPlugin(); virtual ~CustomThrusterPlugin(); virtual void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf); virtual void Update(); private: void ThrusterCallback(const modcube_msgs::ThrusterCommand::ConstPtr&amp; msg); physics::ModelPtr model_; physics::LinkPtr link_; event::ConnectionPtr update_connection_; ros::NodeHandle nh_; ros::Subscriber thruster_sub_; double thrust_force_; math::Vector3 thrust_direction_; }; } . ROS Plugin API . Custom Sensor Plugin . # custom_sensor_plugin.py import rospy from sensor_msgs.msg import PointCloud2 from modcube_msgs.msg import CustomSensorData class CustomSensorPlugin: def __init__(self): self.pub = rospy.Publisher('/modcube/custom_sensor', CustomSensorData, queue_size=10) self.sub = rospy.Subscriber('/camera/depth/points', PointCloud2, self.pointcloud_callback) def pointcloud_callback(self, msg): # Process point cloud data processed_data = self.process_pointcloud(msg) # Publish custom sensor data custom_msg = CustomSensorData() custom_msg.header = msg.header custom_msg.data = processed_data self.pub.publish(custom_msg) def process_pointcloud(self, pointcloud): # Custom processing logic return processed_data . ",
    "url": "/ModCube.github.io/api/#plugin-apis",
    
    "relUrl": "/api/#plugin-apis"
  },"10": {
    "doc": "API Documentation",
    "title": "Examples",
    "content": "Basic Control Example . #!/usr/bin/env python import rospy from modcube_common.motion import MotionClient from geometry_msgs.msg import Pose, Point, Quaternion def main(): rospy.init_node('basic_control_example') # Initialize motion client motion = MotionClient() # Wait for system to be ready rospy.sleep(2.0) # Move to different positions positions = [ (0, 0, -1), (5, 0, -1), (5, 5, -1), (0, 5, -1), (0, 0, -1) ] for pos in positions: rospy.loginfo(f\"Moving to position: {pos}\") success = motion.goto_position(pos[0], pos[1], pos[2], timeout=30.0) if success: rospy.loginfo(\"Position reached successfully\") else: rospy.logwarn(\"Failed to reach position\") rospy.sleep(2.0) rospy.loginfo(\"Mission completed\") if __name__ == '__main__': main() . Advanced Trajectory Following Example . #!/usr/bin/env python import rospy import numpy as np from modcube_common.trajectory import DroneTrajectory, TrajectoryWaypoint from modcube_common.motion import MotionClient from geometry_msgs.msg import Point def main(): rospy.init_node('trajectory_following_example') # Initialize trajectory generator and motion client trajectory = DroneTrajectory() motion = MotionClient() # Define waypoints for a complex 3D trajectory waypoints = [ TrajectoryWaypoint([0, 0, -1]), TrajectoryWaypoint([10, 0, -1]), TrajectoryWaypoint([10, 10, -3]), TrajectoryWaypoint([0, 10, -5]), TrajectoryWaypoint([0, 0, -3]), TrajectoryWaypoint([0, 0, -1]) ] # Set velocity constraints for smooth motion waypoints[0].set_velocity_constraint([0, 0, 0]) # Start from rest waypoints[-1].set_velocity_constraint([0, 0, 0]) # End at rest # Generate optimal trajectory rospy.loginfo(\"Generating optimal trajectory...\") success = trajectory.solve( waypoints=waypoints, aggressiveness=0.7, start_vel=np.array([0, 0, 0]), end_vel=np.array([0, 0, 0]) ) if not success: rospy.logerr(\"Failed to generate trajectory\") return # Convert to ROS path message path_msg = trajectory.to_path_msg(dt=0.1) # Follow the trajectory rospy.loginfo(f\"Following trajectory (duration: {trajectory.get_total_time():.2f}s)\") success = motion.follow_trajectory(path_msg) if success: rospy.loginfo(\"Trajectory completed successfully\") else: rospy.logwarn(\"Trajectory following failed\") if __name__ == '__main__': main() . Multi-Sensor State Estimation Example . #!/usr/bin/env python import rospy import numpy as np from modcube_common.state_estimation import ExtendedKalmanFilter from sensor_msgs.msg import Imu from modcube_msgs.msg import DVLData, FluidDepth, NavState from geometry_msgs.msg import PoseWithCovariance class StateEstimationNode: def __init__(self): rospy.init_node('state_estimation_example') # Initialize EKF initial_state = np.zeros(15) # [pos, vel, acc, euler, ang_vel] initial_cov = np.eye(15) * 0.1 self.ekf = ExtendedKalmanFilter(initial_state, initial_cov) # Subscribers self.imu_sub = rospy.Subscriber('/modcube/imu/data', Imu, self.imu_callback) self.dvl_sub = rospy.Subscriber('/modcube/dvl/data', DVLData, self.dvl_callback) self.depth_sub = rospy.Subscriber('/modcube/depth', FluidDepth, self.depth_callback) # Publishers self.nav_pub = rospy.Publisher('/modcube/nav_state', NavState, queue_size=10) # Timing self.last_prediction_time = rospy.Time.now() # Timer for regular state publishing self.timer = rospy.Timer(rospy.Duration(0.02), self.publish_state) # 50 Hz rospy.loginfo(\"State estimation node initialized\") def imu_callback(self, msg): # Extract IMU data accel = np.array([msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z]) ang_vel = np.array([msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z]) # Optional orientation from IMU orientation = None if msg.orientation_covariance[0] &gt; 0: orientation = np.array([msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w]) # Prediction step current_time = rospy.Time.now() dt = (current_time - self.last_prediction_time).to_sec() if dt &gt; 0: self.ekf.predict(dt) self.last_prediction_time = current_time # Update with IMU measurement self.ekf.update_imu(accel, ang_vel, orientation) def dvl_callback(self, msg): # Extract DVL velocity velocity = np.array([msg.velocity.x, msg.velocity.y, msg.velocity.z]) # Update with DVL measurement self.ekf.update_dvl(velocity, msg.altitude) def depth_callback(self, msg): # Update with depth measurement self.ekf.update_depth(msg.depth) def publish_state(self, event): # Get current state estimate state = self.ekf.get_state() covariance = self.ekf.get_covariance() # Create NavState message nav_msg = NavState() nav_msg.header.stamp = rospy.Time.now() nav_msg.header.frame_id = \"world\" # Position and orientation nav_msg.pose.pose.position.x = state['position'][0] nav_msg.pose.pose.position.y = state['position'][1] nav_msg.pose.pose.position.z = state['position'][2] # Convert Euler angles to quaternion from tf.transformations import quaternion_from_euler q = quaternion_from_euler(state['orientation'][0], state['orientation'][1], state['orientation'][2]) nav_msg.pose.pose.orientation.x = q[0] nav_msg.pose.pose.orientation.y = q[1] nav_msg.pose.pose.orientation.z = q[2] nav_msg.pose.pose.orientation.w = q[3] # Velocity nav_msg.twist.twist.linear.x = state['velocity'][0] nav_msg.twist.twist.linear.y = state['velocity'][1] nav_msg.twist.twist.linear.z = state['velocity'][2] # Angular velocity nav_msg.twist.twist.angular.x = state['angular_velocity'][0] nav_msg.twist.twist.angular.y = state['angular_velocity'][1] nav_msg.twist.twist.angular.z = state['angular_velocity'][2] # Covariance (simplified - position only) nav_msg.pose.covariance[0] = covariance[0, 0] # x-x nav_msg.pose.covariance[7] = covariance[1, 1] # y-y nav_msg.pose.covariance[14] = covariance[2, 2] # z-z # Publish self.nav_pub.publish(nav_msg) def run(self): rospy.spin() if __name__ == '__main__': try: node = StateEstimationNode() node.run() except rospy.ROSInterruptException: pass . Autonomous Survey Mission Example . #!/usr/bin/env python import rospy import numpy as np from modcube_mission import MissionManager from modcube_common.navigation import PathPlanner, ObstacleAvoidance from modcube_common.motion import MotionClient from modcube_msgs.msg import NavState from sensor_msgs.msg import PointCloud2 from nav_msgs.msg import OccupancyGrid class AutonomousSurveyMission: def __init__(self): rospy.init_node('autonomous_survey_mission') # Initialize components self.motion = MotionClient() self.path_planner = PathPlanner(planning_algorithm='A*') self.obstacle_avoidance = ObstacleAvoidance(safety_distance=3.0) # Mission parameters self.survey_area = { 'min_x': 0, 'max_x': 50, 'min_y': 0, 'max_y': 30, 'depth': -5.0 } self.line_spacing = 5.0 # meters between survey lines self.survey_speed = 1.0 # m/s # State tracking self.current_pose = None self.obstacles = [] # Subscribers self.nav_sub = rospy.Subscriber('/modcube/nav_state', NavState, self.nav_callback) self.sonar_sub = rospy.Subscriber('/modcube/sonar/pointcloud', PointCloud2, self.sonar_callback) self.map_sub = rospy.Subscriber('/modcube/occupancy_grid', OccupancyGrid, self.map_callback) rospy.loginfo(\"Autonomous survey mission initialized\") def nav_callback(self, msg): self.current_pose = msg.pose.pose def sonar_callback(self, msg): # Process sonar data for obstacle detection self.obstacle_avoidance.update_obstacles({'sonar': msg}) def map_callback(self, msg): # Update path planner with new map self.path_planner.update_map(msg) def generate_survey_pattern(self): \"\"\"Generate lawnmower survey pattern.\"\"\" waypoints = [] y = self.survey_area['min_y'] direction = 1 # 1 for positive x, -1 for negative x while y &lt;= self.survey_area['max_y']: if direction == 1: # Left to right start_x = self.survey_area['min_x'] end_x = self.survey_area['max_x'] else: # Right to left start_x = self.survey_area['max_x'] end_x = self.survey_area['min_x'] waypoints.append([start_x, y, self.survey_area['depth']]) waypoints.append([end_x, y, self.survey_area['depth']]) y += self.line_spacing direction *= -1 return waypoints def execute_survey(self): \"\"\"Execute the survey mission.\"\"\" rospy.loginfo(\"Starting autonomous survey mission\") # Wait for initial position while self.current_pose is None and not rospy.is_shutdown(): rospy.loginfo(\"Waiting for navigation state...\") rospy.sleep(1.0) # Generate survey pattern waypoints = self.generate_survey_pattern() rospy.loginfo(f\"Generated {len(waypoints)} waypoints\") # Execute waypoints with obstacle avoidance for i, waypoint in enumerate(waypoints): rospy.loginfo(f\"Navigating to waypoint {i+1}/{len(waypoints)}: {waypoint}\") # Plan path to waypoint current_pos = np.array([ self.current_pose.position.x, self.current_pose.position.y, self.current_pose.position.z ]) path = self.path_planner.plan_path( start=current_pos, goal=np.array(waypoint), constraints={'max_velocity': self.survey_speed} ) if path is None: rospy.logwarn(f\"Failed to plan path to waypoint {i+1}\") continue # Execute path with real-time obstacle avoidance success = self.execute_path_with_avoidance(path) if not success: rospy.logwarn(f\"Failed to reach waypoint {i+1}\") # Decide whether to continue or abort mission continue rospy.loginfo(f\"Reached waypoint {i+1}\") rospy.loginfo(\"Survey mission completed\") def execute_path_with_avoidance(self, path): \"\"\"Execute path with real-time obstacle avoidance.\"\"\" rate = rospy.Rate(10) # 10 Hz control loop for waypoint in path: # Check for obstacles and compute avoidance current_pos = np.array([ self.current_pose.position.x, self.current_pose.position.y, self.current_pose.position.z ]) target_velocity = (np.array(waypoint) - current_pos) target_velocity = target_velocity / np.linalg.norm(target_velocity) * self.survey_speed # Compute obstacle avoidance force avoidance_force = self.obstacle_avoidance.compute_avoidance_force( current_pos, self.obstacles, target_velocity ) # Combine target velocity with avoidance modified_velocity = target_velocity + avoidance_force # Send velocity command success = self.motion.goto_position( waypoint[0], waypoint[1], waypoint[2], timeout=10.0 ) if not success: return False rate.sleep() return True def run(self): \"\"\"Run the mission.\"\"\" try: self.execute_survey() except rospy.ROSInterruptException: rospy.loginfo(\"Mission interrupted\") except Exception as e: rospy.logerr(f\"Mission failed: {e}\") if __name__ == '__main__': mission = AutonomousSurveyMission() mission.run() . Mission Planning Example . #!/usr/bin/env python import rospy from modcube_mission import MissionManager from modcube_mission.missions import WaypointMission, SearchMission def main(): rospy.init_node('mission_example') # Initialize mission manager mission_mgr = MissionManager() # Register custom mission types mission_mgr.register_mission_type('waypoint', WaypointMission) mission_mgr.register_mission_type('search', SearchMission) # Start waypoint mission waypoint_params = { 'waypoints': [ {'x': 0, 'y': 0, 'z': -1}, {'x': 10, 'y': 0, 'z': -1}, {'x': 10, 'y': 10, 'z': -1}, {'x': 0, 'y': 10, 'z': -1} ], 'speed': 0.5 } mission_id = mission_mgr.start_mission('waypoint', waypoint_params) rospy.loginfo(f\"Started mission: {mission_id}\") # Monitor mission progress rate = rospy.Rate(1) # 1 Hz while not rospy.is_shutdown(): status = mission_mgr.get_mission_status(mission_id) rospy.loginfo(f\"Mission status: {status['state']}\") if status['state'] == 'completed': break rate.sleep() rospy.loginfo(\"Mission completed successfully\") if __name__ == '__main__': main() . Sensor Integration Example . #!/usr/bin/env python import rospy from modcube_common.state_estimation import StateEstimator from sensor_msgs.msg import Imu from modcube_msgs.msg import DVLData, NavState def main(): rospy.init_node('sensor_integration_example') # Initialize state estimator estimator = StateEstimator() # Add sensors estimator.add_sensor('imu', '/modcube/imu/data', 'imu_link') estimator.add_sensor('dvl', '/modcube/dvl/data', 'dvl_link') estimator.add_sensor('depth', '/modcube/depth', 'depth_link') # Publisher for estimated state nav_pub = rospy.Publisher('/modcube/nav_state', NavState, queue_size=10) rate = rospy.Rate(50) # 50 Hz while not rospy.is_shutdown(): # Get current estimated state state = estimator.get_state() # Publish state nav_pub.publish(state) rate.sleep() if __name__ == '__main__': main() . This API documentation provides a comprehensive reference for developing with the RS-ModCubes system. For more examples and detailed usage, refer to the source code and example implementations in the repository. ",
    "url": "/ModCube.github.io/api/#examples",
    
    "relUrl": "/api/#examples"
  },"11": {
    "doc": "System Architecture",
    "title": "System Architecture",
    "content": "The RS-ModCubes system is built on a modular, scalable architecture designed for underwater robotics applications. This document provides a comprehensive overview of the system’s technical architecture, component interactions, and design principles. ",
    "url": "/ModCube.github.io/architecture/",
    
    "relUrl": "/architecture/"
  },"12": {
    "doc": "System Architecture",
    "title": "Overview",
    "content": "The ModCube system follows a distributed architecture pattern with clear separation of concerns across multiple ROS packages. Each package serves a specific purpose while maintaining loose coupling with other components through well-defined interfaces. graph TB subgraph \"Mission Layer\" MM[Mission Manager] MP[Mission Planner] end subgraph \"Control Layer\" GNC[Guidance Navigation Control] PID[PID Controller] TM[Thruster Manager] end subgraph \"Hardware Layer\" IMU[IMU Sensors] DVL[DVL Sensors] CAM[Cameras] THR[Thrusters] end subgraph \"Simulation Layer\" GAZ[Gazebo Simulator] WORLD[Simulation Worlds] end MM --&gt; GNC MP --&gt; GNC GNC --&gt; PID PID --&gt; TM TM --&gt; THR IMU --&gt; GNC DVL --&gt; GNC CAM --&gt; GNC GAZ --&gt; WORLD GAZ --&gt; THR . ",
    "url": "/ModCube.github.io/architecture/#overview",
    
    "relUrl": "/architecture/#overview"
  },"13": {
    "doc": "System Architecture",
    "title": "Core Packages",
    "content": "modcube_common . Purpose: Core frameworks, libraries, and system-wide utilities . Key Components: . | Controllers: PID controllers, motion controllers | Planners: Trajectory planners, path planners | State Estimation: Navigation state processing | Thruster Management: Thrust allocation and control | Utilities: Common helper functions and tools | . Dependencies: . | roscpp, rospy | geometry_msgs, sensor_msgs | tf, tf2 | vision_msgs | modcube_msgs | . modcube_mission . Purpose: Mission-specific code and high-level system orchestration . Key Components: . | Mission Manager: Central mission coordination | Task Execution: Individual task handlers | System Launch: Configurable system startup | Mission Planning: High-level mission planning algorithms | . Features: . | Configurable launch system with model_name and simulated parameters | Integration with simulator and vehicle-specific components | Mission state management and monitoring | . modcube_vehicle . Purpose: Vehicle-specific hardware drivers and configurations . Key Components: . | IMU Manager: Inertial measurement unit data processing | Depth Sensor: Blue Robotics depth sensor integration | Actuators: Pololu Maestro PWM module control for thrusters | Joint State Publisher: Default joint state publishing | Static Transforms: Static transform broadcasting | . Supported Hardware: . | Xsens IMU systems | Teledyne DVL systems | Blue Robotics depth sensors | Pololu Maestro PWM controllers | . modcube_msgs . Purpose: Custom message and service definitions . Message Types: . | Sensor Data: IMU, DVL, depth, sonar | Control Commands: Thrust, servo, trajectory | Detection Results: AprilTag, gate, feature detection | System Status: Alarms, battery, navigation state | Tuning Parameters: PID, dynamics tuning | . modcube_config . Purpose: System configuration and robot descriptions . Structure: . | modcube_description: Physical robot configuration | modcube_sim_description: Simulation-specific configuration | . Configuration Files: . | Thruster configurations (14-thruster setup) | Sensor calibrations | Control parameters | Launch file templates | . modcube_sim . Purpose: Simulation environment and sensor processing . Components: . | Camera data processing | Disparity to depth conversion | Simulation-specific utilities | . modcube_sim_worlds . Purpose: Simulation environments and world models . Available Worlds: . | Base Pool: Basic testing environment | Transdec: Complex underwater environment | UMD: University of Maryland test environment | . Models: . | Buoys and markers | Torpedo targets | Environmental obstacles | Vehicle models | . ",
    "url": "/ModCube.github.io/architecture/#core-packages",
    
    "relUrl": "/architecture/#core-packages"
  },"14": {
    "doc": "System Architecture",
    "title": "Control System Architecture",
    "content": "Guidance, Navigation, and Control (GNC) . The GNC system implements a hierarchical control architecture: . | Mission Level: High-level mission planning and task allocation | Guidance Level: Path planning and trajectory generation | Navigation Level: State estimation and localization | Control Level: Low-level control and actuation | . PID Control Implementation . # Simplified PID controller structure class PIDController: def __init__(self): self.position_pid = PID() self.orientation_pid = PID() def compute_wrench(self, state, setpoint): # Position error calculation pos_error = setpoint.position - state.position # Orientation error calculation orient_error = self.compute_orientation_error(setpoint, state) # PID computation force = self.position_pid.compute(pos_error) torque = self.orientation_pid.compute(orient_error) return Wrench(force, torque) . Thruster Allocation . The system uses a 14-thruster configuration with sophisticated allocation algorithms: . Thrust Allocation Matrix (TAM) . class ThrusterManager { public: // 14-thruster configuration matrix (6 DOF -&gt; 14 thrusters) // Maps [Fx, Fy, Fz, Tx, Ty, Tz] to individual thruster forces Eigen::Matrix&lt;double, 14, 6&gt; allocation_matrix_; std::vector&lt;double&gt; allocateThrust(const geometry_msgs::Wrench&amp; desired_wrench) { // Convert ROS message to Eigen vector Eigen::Vector6d wrench; wrench &lt;&lt; desired_wrench.force.x, desired_wrench.force.y, desired_wrench.force.z, desired_wrench.torque.x, desired_wrench.torque.y, desired_wrench.torque.z; // Pseudo-inverse allocation Eigen::VectorXd thrust_commands = allocation_matrix_.completeOrthogonalDecomposition().solve(wrench); // Apply thrust limits and saturation for (int i = 0; i &lt; thrust_commands.size(); ++i) { thrust_commands(i) = std::clamp(thrust_commands(i), -max_thrust_, max_thrust_); } // Handle thruster failures applyFailureCompensation(thrust_commands); // Convert to std::vector return std::vector&lt;double&gt;(thrust_commands.data(), thrust_commands.data() + thrust_commands.size()); } private: void applyFailureCompensation(Eigen::VectorXd&amp; thrust_commands) { // Redistribute thrust if thrusters are failed for (int i = 0; i &lt; failed_thrusters_.size(); ++i) { if (failed_thrusters_[i]) { thrust_commands(i) = 0.0; // Redistribute to healthy thrusters using optimization redistributeThrustLoad(i, thrust_commands); } } } void redistributeThrustLoad(int failed_thruster, Eigen::VectorXd&amp; thrust_commands) { // Quadratic programming approach for optimal redistribution // Minimize: ||T||² subject to: A*T = F and thrust limits // Create modified allocation matrix without failed thruster Eigen::MatrixXd A_modified = allocation_matrix_; A_modified.row(failed_thruster).setZero(); // Solve constrained optimization problem // Implementation details depend on chosen QP solver } }; . Dynamic Reconfiguration . void ThrusterManager::updateThrusterConfiguration(const ThrusterConfig&amp; config) { // Update thruster positions and orientations for (size_t i = 0; i &lt; config.thrusters.size(); ++i) { thruster_positions_[i] = config.thrusters[i].position; thruster_orientations_[i] = config.thrusters[i].orientation; } // Recompute allocation matrix computeAllocationMatrix(); // Update thrust limits max_thrust_ = config.max_thrust; ROS_INFO(\"Thruster configuration updated\"); } void ThrusterManager::computeAllocationMatrix() { allocation_matrix_.setZero(); for (int i = 0; i &lt; num_thrusters_; ++i) { Eigen::Vector3d pos = thruster_positions_[i]; Eigen::Vector3d dir = thruster_orientations_[i]; // Force contribution (columns 0-2) allocation_matrix_.block&lt;1, 3&gt;(i, 0) = dir.transpose(); // Torque contribution (columns 3-5) Eigen::Vector3d torque = pos.cross(dir); allocation_matrix_.block&lt;1, 3&gt;(i, 3) = torque.transpose(); } } . ",
    "url": "/ModCube.github.io/architecture/#control-system-architecture",
    
    "relUrl": "/architecture/#control-system-architecture"
  },"15": {
    "doc": "System Architecture",
    "title": "Trajectory Generation and Path Planning",
    "content": "Minimum Snap Trajectory Optimization . class DroneTrajectory { public: bool solve(const std::vector&lt;TrajectoryWaypoint&gt;&amp; waypoints, double aggressiveness = 0.5, const Eigen::Vector3d&amp; start_vel = Eigen::Vector3d::Zero(), const Eigen::Vector3d&amp; end_vel = Eigen::Vector3d::Zero()) { int n_segments = waypoints.size() - 1; int n_coeffs = 8; // 7th order polynomials // Time allocation std::vector&lt;double&gt; segment_times = allocateTime(waypoints, aggressiveness); // Setup optimization problem // Minimize: ∫ ||d⁴r/dt⁴||² dt (snap minimization) // Subject to: waypoint constraints, continuity constraints Eigen::MatrixXd Q = computeSnapCostMatrix(segment_times); Eigen::MatrixXd A = computeConstraintMatrix(waypoints, segment_times); Eigen::VectorXd b = computeConstraintVector(waypoints, start_vel, end_vel); // Solve quadratic program: min 0.5*x'*Q*x subject to A*x = b Eigen::VectorXd coefficients = solveQP(Q, A, b); // Store trajectory coefficients storeTrajectoryCoefficients(coefficients, segment_times, n_segments, n_coeffs); return true; } Eigen::Vector3d getPosition(double t) const { int segment = findSegment(t); double t_local = t - segment_start_times_[segment]; Eigen::Vector3d position = Eigen::Vector3d::Zero(); for (int i = 0; i &lt; 8; ++i) { position += coefficients_[segment].block&lt;3, 1&gt;(0, i) * std::pow(t_local, i); } return position; } Eigen::Vector3d getVelocity(double t) const { int segment = findSegment(t); double t_local = t - segment_start_times_[segment]; Eigen::Vector3d velocity = Eigen::Vector3d::Zero(); for (int i = 1; i &lt; 8; ++i) { velocity += i * coefficients_[segment].block&lt;3, 1&gt;(0, i) * std::pow(t_local, i-1); } return velocity; } Eigen::Vector3d getAcceleration(double t) const { int segment = findSegment(t); double t_local = t - segment_start_times_[segment]; Eigen::Vector3d acceleration = Eigen::Vector3d::Zero(); for (int i = 2; i &lt; 8; ++i) { acceleration += i * (i-1) * coefficients_[segment].block&lt;3, 1&gt;(0, i) * std::pow(t_local, i-2); } return acceleration; } private: std::vector&lt;double&gt; allocateTime(const std::vector&lt;TrajectoryWaypoint&gt;&amp; waypoints, double aggressiveness) { std::vector&lt;double&gt; times; for (size_t i = 1; i &lt; waypoints.size(); ++i) { Eigen::Vector3d diff = waypoints[i].position - waypoints[i-1].position; double distance = diff.norm(); // Heuristic time allocation based on distance and aggressiveness double base_time = distance / (2.0 * aggressiveness + 0.5); times.push_back(std::max(base_time, 0.5)); // Minimum 0.5s per segment } return times; } Eigen::MatrixXd computeSnapCostMatrix(const std::vector&lt;double&gt;&amp; times) { int n_segments = times.size(); int n_coeffs = 8; int total_vars = n_segments * n_coeffs * 3; // 3D trajectory Eigen::MatrixXd Q = Eigen::MatrixXd::Zero(total_vars, total_vars); for (int seg = 0; seg &lt; n_segments; ++seg) { double T = times[seg]; // Snap cost matrix for 7th order polynomial Eigen::MatrixXd Q_seg = Eigen::MatrixXd::Zero(n_coeffs, n_coeffs); for (int i = 4; i &lt; n_coeffs; ++i) { for (int j = 4; j &lt; n_coeffs; ++j) { if (i + j &gt;= 7) { double coeff = factorial(i) * factorial(j) / (factorial(i-4) * factorial(j-4) * (i + j - 7)); Q_seg(i, j) = coeff * std::pow(T, i + j - 7); } } } // Place in global matrix for each dimension for (int dim = 0; dim &lt; 3; ++dim) { int offset = (seg * 3 + dim) * n_coeffs; Q.block(offset, offset, n_coeffs, n_coeffs) = Q_seg; } } return Q; } }; . A* Path Planning . class PathPlanner { public: struct Node { Eigen::Vector3i grid_pos; Eigen::Vector3d world_pos; double g_cost; // Cost from start double h_cost; // Heuristic cost to goal double f_cost; // Total cost std::shared_ptr&lt;Node&gt; parent; bool operator&lt;(const Node&amp; other) const { return f_cost &gt; other.f_cost; // For min-heap } }; std::vector&lt;Eigen::Vector3d&gt; planPath(const Eigen::Vector3d&amp; start, const Eigen::Vector3d&amp; goal, const nav_msgs::OccupancyGrid&amp; map) { // Convert world coordinates to grid coordinates Eigen::Vector3i start_grid = worldToGrid(start, map); Eigen::Vector3i goal_grid = worldToGrid(goal, map); // Initialize open and closed sets std::priority_queue&lt;Node&gt; open_set; std::unordered_set&lt;Eigen::Vector3i, Vector3iHash&gt; closed_set; // Start node Node start_node; start_node.grid_pos = start_grid; start_node.world_pos = start; start_node.g_cost = 0.0; start_node.h_cost = heuristic(start_grid, goal_grid); start_node.f_cost = start_node.g_cost + start_node.h_cost; start_node.parent = nullptr; open_set.push(start_node); while (!open_set.empty()) { Node current = open_set.top(); open_set.pop(); // Check if goal reached if (current.grid_pos == goal_grid) { return reconstructPath(current); } closed_set.insert(current.grid_pos); // Explore neighbors (26-connectivity in 3D) for (int dx = -1; dx &lt;= 1; ++dx) { for (int dy = -1; dy &lt;= 1; ++dy) { for (int dz = -1; dz &lt;= 1; ++dz) { if (dx == 0 &amp;&amp; dy == 0 &amp;&amp; dz == 0) continue; Eigen::Vector3i neighbor_grid = current.grid_pos + Eigen::Vector3i(dx, dy, dz); // Check bounds and obstacles if (!isValidCell(neighbor_grid, map) || closed_set.count(neighbor_grid)) { continue; } // Calculate costs double movement_cost = std::sqrt(dx*dx + dy*dy + dz*dz); double tentative_g = current.g_cost + movement_cost; Node neighbor; neighbor.grid_pos = neighbor_grid; neighbor.world_pos = gridToWorld(neighbor_grid, map); neighbor.g_cost = tentative_g; neighbor.h_cost = heuristic(neighbor_grid, goal_grid); neighbor.f_cost = neighbor.g_cost + neighbor.h_cost; neighbor.parent = std::make_shared&lt;Node&gt;(current); open_set.push(neighbor); } } } } return {}; // No path found } private: double heuristic(const Eigen::Vector3i&amp; a, const Eigen::Vector3i&amp; b) { // Euclidean distance heuristic Eigen::Vector3i diff = a - b; return std::sqrt(diff.x()*diff.x() + diff.y()*diff.y() + diff.z()*diff.z()); } std::vector&lt;Eigen::Vector3d&gt; reconstructPath(const Node&amp; goal_node) { std::vector&lt;Eigen::Vector3d&gt; path; std::shared_ptr&lt;Node&gt; current = std::make_shared&lt;Node&gt;(goal_node); while (current != nullptr) { path.push_back(current-&gt;world_pos); current = current-&gt;parent; } std::reverse(path.begin(), path.end()); return path; } }; . ",
    "url": "/ModCube.github.io/architecture/#trajectory-generation-and-path-planning",
    
    "relUrl": "/architecture/#trajectory-generation-and-path-planning"
  },"16": {
    "doc": "System Architecture",
    "title": "State Estimation",
    "content": "Extended Kalman Filter (EKF) Implementation . The core state estimation uses a 15-state Extended Kalman Filter: . State Vector (15 elements): . x = [px, py, pz, # Position (3) vx, vy, vz, # Velocity (3) ax, ay, az, # Acceleration (3) φ, θ, ψ, # Euler angles (3) ωx, ωy, ωz] # Angular velocity (3) . Process Model: . // Simplified process model void Ekf::predict(double dt) { // Position integration state_.segment&lt;3&gt;(0) += state_.segment&lt;3&gt;(3) * dt + 0.5 * state_.segment&lt;3&gt;(6) * dt * dt; // Velocity integration state_.segment&lt;3&gt;(3) += state_.segment&lt;3&gt;(6) * dt; // Orientation integration (using angular velocity) Eigen::Vector3d euler_rates = computeEulerRates(state_.segment&lt;3&gt;(9), state_.segment&lt;3&gt;(12)); state_.segment&lt;3&gt;(9) += euler_rates * dt; // Wrap angles wrapAngles(); // Covariance prediction Eigen::MatrixXd F = computeJacobianF(dt); Eigen::MatrixXd Q = process_noise_cov_; covariance_ = F * covariance_ * F.transpose() + Q; } . Multi-Sensor Fusion Architecture . IMU Integration . void Ekf::updateImu(const Eigen::Vector3d&amp; accel, const Eigen::Vector3d&amp; gyro, const Eigen::Vector4d* orientation) { // Acceleration measurement model Eigen::Vector3d h_accel = state_.segment&lt;3&gt;(6); // Expected acceleration Eigen::Vector3d innovation_accel = accel - h_accel; // Angular velocity measurement model Eigen::Vector3d h_gyro = state_.segment&lt;3&gt;(12); // Expected angular velocity Eigen::Vector3d innovation_gyro = gyro - h_gyro; // Measurement Jacobian Eigen::MatrixXd H = computeImuJacobian(); // Kalman update performKalmanUpdate(H, innovation_accel, imu_noise_cov_); performKalmanUpdate(H, innovation_gyro, gyro_noise_cov_); // Optional orientation update if (orientation) { updateOrientation(*orientation); } } . DVL Integration . void Ekf::updateDvl(const Eigen::Vector3d&amp; velocity, double altitude) { // Transform DVL velocity to world frame Eigen::Matrix3d R = getRotationMatrix(); Eigen::Vector3d velocity_world = R * velocity; // Velocity measurement model Eigen::Vector3d h_vel = state_.segment&lt;3&gt;(3); // Expected velocity Eigen::Vector3d innovation = velocity_world - h_vel; // Measurement Jacobian Eigen::MatrixXd H = computeDvlJacobian(); // Kalman update performKalmanUpdate(H, innovation, dvl_noise_cov_); // Altitude constraint (if available) if (altitude &gt; 0) { updateAltitude(altitude); } } . Depth Sensor Integration . void Ekf::updateDepth(double depth) { // Depth measurement model (z-position) double h_depth = state_(2); // Expected depth double innovation = depth - h_depth; // Simple measurement Jacobian (1x15) Eigen::MatrixXd H = Eigen::MatrixXd::Zero(1, 15); H(0, 2) = 1.0; // ∂h/∂z = 1 // Kalman update Eigen::MatrixXd R = Eigen::MatrixXd::Identity(1, 1) * depth_noise_var_; performKalmanUpdate(H, Eigen::VectorXd::Constant(1, innovation), R); } . Visual Odometry Integration . class VisualOdometry { public: struct PoseEstimate { Eigen::Vector3d position; Eigen::Quaterniond orientation; Eigen::Matrix6d covariance; double confidence; ros::Time timestamp; }; PoseEstimate processFrame(const cv::Mat&amp; image, ros::Time timestamp) { // Feature detection and matching std::vector&lt;cv::KeyPoint&gt; keypoints; cv::Mat descriptors; detector_-&gt;detectAndCompute(image, cv::noArray(), keypoints, descriptors); // Match with previous frame std::vector&lt;cv::DMatch&gt; matches; if (!prev_descriptors_.empty()) { matcher_-&gt;match(prev_descriptors_, descriptors, matches); // Filter good matches std::vector&lt;cv::DMatch&gt; good_matches; filterMatches(matches, good_matches); // Estimate motion if (good_matches.size() &gt;= min_features_) { return estimateMotion(prev_keypoints_, keypoints, good_matches); } } // Store for next iteration prev_keypoints_ = keypoints; prev_descriptors_ = descriptors.clone(); return PoseEstimate{}; // Invalid estimate } private: PoseEstimate estimateMotion(const std::vector&lt;cv::KeyPoint&gt;&amp; prev_kpts, const std::vector&lt;cv::KeyPoint&gt;&amp; curr_kpts, const std::vector&lt;cv::DMatch&gt;&amp; matches) { // Extract matched points std::vector&lt;cv::Point2f&gt; prev_pts, curr_pts; for (const auto&amp; match : matches) { prev_pts.push_back(prev_kpts[match.queryIdx].pt); curr_pts.push_back(curr_kpts[match.trainIdx].pt); } // Estimate essential matrix cv::Mat E, mask; E = cv::findEssentialMat(prev_pts, curr_pts, camera_matrix_, cv::RANSAC, 0.999, 1.0, mask); // Recover pose cv::Mat R, t; int inliers = cv::recoverPose(E, prev_pts, curr_pts, camera_matrix_, R, t, mask); // Convert to Eigen and compute covariance Eigen::Matrix3d R_eigen; Eigen::Vector3d t_eigen; cv::cv2eigen(R, R_eigen); cv::cv2eigen(t, t_eigen); // Estimate covariance based on inlier ratio and feature quality double confidence = static_cast&lt;double&gt;(inliers) / matches.size(); Eigen::Matrix6d covariance = computePoseCovariance(confidence, inliers); PoseEstimate estimate; estimate.position = t_eigen; estimate.orientation = Eigen::Quaterniond(R_eigen); estimate.covariance = covariance; estimate.confidence = confidence; estimate.timestamp = ros::Time::now(); return estimate; } }; . Navigation State . The comprehensive navigation state includes: . struct NavigationState { // Kinematic state Eigen::Vector3d position; // [x, y, z] in world frame Eigen::Vector3d velocity; // [vx, vy, vz] in world frame Eigen::Vector3d acceleration; // [ax, ay, az] in world frame // Orientation state Eigen::Vector3d euler_angles; // [roll, pitch, yaw] Eigen::Quaterniond quaternion; // Orientation quaternion Eigen::Vector3d angular_velocity; // [ωx, ωy, ωz] in body frame // Uncertainty quantification Eigen::Matrix&lt;double, 15, 15&gt; covariance; // Full state covariance // Quality metrics double position_accuracy; // Position estimate accuracy (m) double orientation_accuracy; // Orientation estimate accuracy (rad) double velocity_accuracy; // Velocity estimate accuracy (m/s) // Sensor health bool imu_healthy; bool dvl_healthy; bool depth_healthy; bool vision_healthy; // Timestamps ros::Time timestamp; ros::Time last_imu_update; ros::Time last_dvl_update; ros::Time last_depth_update; ros::Time last_vision_update; }; . ",
    "url": "/ModCube.github.io/architecture/#state-estimation",
    
    "relUrl": "/architecture/#state-estimation"
  },"17": {
    "doc": "System Architecture",
    "title": "Communication Architecture",
    "content": "ROS Topics . Control Topics: . | /modcube/controller_command: Control commands | /modcube/nav_state: Navigation state | /modcube/thrust: Thruster commands | . Sensor Topics: . | /modcube/imu: IMU data | /modcube/dvl: DVL data | /modcube/depth: Depth measurements | . Mission Topics: . | /modcube/mission_state: Mission status | /modcube/task_command: Task commands | . ROS Services . Configuration Services: . | set_pid_params: PID parameter tuning | set_thruster_config: Thruster configuration | mission_control: Mission management | . ",
    "url": "/ModCube.github.io/architecture/#communication-architecture",
    
    "relUrl": "/architecture/#communication-architecture"
  },"18": {
    "doc": "System Architecture",
    "title": "Simulation Integration",
    "content": "Gazebo Integration . The system integrates with Gazebo through: . | UUV Simulator: Underwater vehicle dynamics | Custom Plugins: ModCube-specific functionality | Sensor Simulation: Realistic sensor modeling | Environmental Modeling: Underwater physics simulation | . Hardware-in-the-Loop (HIL) . Support for HIL testing: . | Real hardware integration with simulated environment | Sensor data injection | Actuator command forwarding | . ",
    "url": "/ModCube.github.io/architecture/#simulation-integration",
    
    "relUrl": "/architecture/#simulation-integration"
  },"19": {
    "doc": "System Architecture",
    "title": "Performance Characteristics",
    "content": "Real-time Performance . | Control Loop: 100 Hz update rate | State Estimation: 50 Hz update rate | Mission Planning: 10 Hz update rate | . Scalability . | Multi-vehicle Support: Distributed architecture | Modular Expansion: Plugin-based component addition | Resource Management: Efficient CPU and memory usage | . ",
    "url": "/ModCube.github.io/architecture/#performance-characteristics",
    
    "relUrl": "/architecture/#performance-characteristics"
  },"20": {
    "doc": "System Architecture",
    "title": "Security and Safety",
    "content": "Safety Systems . | Alarm System: Real-time fault detection | Emergency Procedures: Automatic safety responses | Redundancy: Critical system backup mechanisms | . Data Security . | Secure Communication: Encrypted data transmission | Access Control: Role-based system access | Data Logging: Comprehensive system monitoring | . ",
    "url": "/ModCube.github.io/architecture/#security-and-safety",
    
    "relUrl": "/architecture/#security-and-safety"
  },"21": {
    "doc": "System Architecture",
    "title": "Development Guidelines",
    "content": "Code Organization . | Package Structure: Clear separation of concerns | Interface Design: Well-defined APIs | Documentation: Comprehensive code documentation | . Testing Strategy . | Unit Testing: Component-level testing | Integration Testing: System-level validation | Simulation Testing: Virtual environment validation | Hardware Testing: Real-world validation | . Version Control . | Git Workflow: Feature branch development | Release Management: Semantic versioning | Continuous Integration: Automated testing and deployment | . ",
    "url": "/ModCube.github.io/architecture/#development-guidelines",
    
    "relUrl": "/architecture/#development-guidelines"
  },"22": {
    "doc": "System Architecture",
    "title": "Future Enhancements",
    "content": "Planned Features . | Machine Learning Integration: AI-based control and planning | Advanced Sensor Fusion: Multi-modal state estimation | Swarm Coordination: Multi-vehicle collaboration | Cloud Integration: Remote monitoring and control | . Research Directions . | Adaptive Control: Self-tuning control systems | Fault Tolerance: Advanced fault detection and recovery | Energy Optimization: Efficient power management | Autonomous Decision Making: High-level autonomy | . This architecture provides a robust foundation for underwater robotics research and applications, with clear pathways for future enhancement and expansion. ",
    "url": "/ModCube.github.io/architecture/#future-enhancements",
    
    "relUrl": "/architecture/#future-enhancements"
  },"23": {
    "doc": "Changelog",
    "title": "Changelog",
    "content": "All notable changes to the RS-ModCubes project will be documented in this file. The format is based on Keep a Changelog, and this project adheres to Semantic Versioning. ",
    "url": "/ModCube.github.io/changelog/",
    
    "relUrl": "/changelog/"
  },"24": {
    "doc": "Changelog",
    "title": "[Unreleased]",
    "content": "Added . | Multi-vehicle formation control algorithms | Advanced sensor fusion with Kalman filtering | Machine learning-based adaptive control | Real-time performance monitoring dashboard | Support for new thruster configurations | Automated mission planning tools | . Changed . | Improved PID controller stability | Enhanced simulation physics accuracy | Optimized communication protocols | Updated documentation structure | . Fixed . | Memory leaks in sensor drivers | Race conditions in multi-threading | Calibration issues with IMU sensors | . ",
    "url": "/ModCube.github.io/changelog/#unreleased",
    
    "relUrl": "/changelog/#unreleased"
  },"25": {
    "doc": "Changelog",
    "title": "[2.1.0] - 2024-03-15",
    "content": "Added . | New Control Algorithms . | Sliding mode controller for robust control | Model predictive control (MPC) implementation | Adaptive PID with auto-tuning capabilities | Formation control for multi-vehicle operations | . | Enhanced Sensor Support . | DVL (Doppler Velocity Log) integration | Multi-beam sonar support | Camera-based visual odometry | Pressure sensor calibration tools | . | Simulation Improvements . | Realistic water current modeling | Improved thruster dynamics | Underwater lighting effects | Particle system for turbidity simulation | . | Mission Planning . | Waypoint navigation with obstacle avoidance | Search pattern generation | Dynamic mission replanning | Mission progress monitoring | . | . Changed . | Performance Optimizations . | Reduced control loop latency by 30% | Optimized memory usage in sensor processing | Improved real-time scheduling | Enhanced multi-threading performance | . | User Interface . | Redesigned control panel layout | Improved parameter tuning interface | Enhanced visualization tools | Better error reporting and diagnostics | . | Documentation . | Comprehensive API documentation | Updated installation guides | New tutorial series | Improved code examples | . | . Fixed . | Critical Fixes . | Fixed deadlock in thruster allocation | Resolved memory corruption in sensor drivers | Fixed race condition in state estimation | Corrected coordinate frame transformations | . | Minor Fixes . | Fixed parameter loading issues | Resolved launch file dependencies | Corrected unit conversions | Fixed logging format inconsistencies | . | . Security . | Added input validation for network commands | Implemented secure communication protocols | Enhanced access control mechanisms | Added audit logging for critical operations | . ",
    "url": "/ModCube.github.io/changelog/#210---2024-03-15",
    
    "relUrl": "/changelog/#210---2024-03-15"
  },"26": {
    "doc": "Changelog",
    "title": "[2.0.0] - 2024-01-20",
    "content": "Added . | Major Architecture Overhaul . | Modular package structure | Plugin-based architecture | Standardized interfaces | Improved error handling | . | New Hardware Support . | Support for multiple vehicle configurations | Configurable thruster arrangements | Hot-swappable sensor modules | Real-time hardware monitoring | . | Advanced Features . | Autonomous mission execution | Dynamic obstacle avoidance | Multi-vehicle coordination | Remote operation capabilities | . | . Changed . | Breaking Changes . | Restructured ROS topic hierarchy | Updated message definitions | Changed configuration file format | Modified API interfaces | . | Migration Guide . | See Migration Guide for detailed instructions | Automated migration tools provided | Backward compatibility layer available | . | . Removed . | Deprecated legacy control modes | Obsolete sensor drivers | Unused configuration parameters | Old simulation models | . ",
    "url": "/ModCube.github.io/changelog/#200---2024-01-20",
    
    "relUrl": "/changelog/#200---2024-01-20"
  },"27": {
    "doc": "Changelog",
    "title": "[1.5.2] - 2023-12-10",
    "content": "Fixed . | Hotfixes . | Critical stability issue in depth control | Memory leak in image processing | Incorrect thruster mapping | Sensor calibration errors | . | . Security . | Patched vulnerability in network communication | Updated dependencies with security fixes | . ",
    "url": "/ModCube.github.io/changelog/#152---2023-12-10",
    
    "relUrl": "/changelog/#152---2023-12-10"
  },"28": {
    "doc": "Changelog",
    "title": "[1.5.1] - 2023-11-25",
    "content": "Fixed . | Bug Fixes . | Fixed orientation drift in navigation | Resolved timing issues in control loop | Corrected parameter validation | Fixed visualization rendering | . | . Changed . | Improved error messages | Enhanced logging verbosity | Updated dependency versions | . ",
    "url": "/ModCube.github.io/changelog/#151---2023-11-25",
    
    "relUrl": "/changelog/#151---2023-11-25"
  },"29": {
    "doc": "Changelog",
    "title": "[1.5.0] - 2023-11-01",
    "content": "Added . | New Features . | Integrated SLAM capabilities | Advanced path planning algorithms | Real-time 3D mapping | Improved user interface | . | Sensor Integration . | Support for stereo cameras | Integrated GPS for surface operations | Enhanced IMU processing | Acoustic positioning system | . | . Changed . | Performance Improvements . | Faster startup times | Reduced CPU usage | Optimized memory allocation | Improved network efficiency | . | . Fixed . | Stability issues in long-duration missions | Calibration problems with new sensors | Compatibility issues with ROS Noetic | . ",
    "url": "/ModCube.github.io/changelog/#150---2023-11-01",
    
    "relUrl": "/changelog/#150---2023-11-01"
  },"30": {
    "doc": "Changelog",
    "title": "[1.4.0] - 2023-09-15",
    "content": "Added . | Control System Enhancements . | Adaptive control algorithms | Disturbance rejection improvements | Multi-mode operation support | Emergency stop functionality | . | Simulation Features . | Realistic ocean environment | Weather condition simulation | Marine life interaction | Equipment failure simulation | . | . Changed . | Updated to ROS Noetic compatibility | Improved configuration management | Enhanced testing framework | Better documentation structure | . Fixed . | Control instability in strong currents | Sensor fusion accuracy issues | Launch file parameter conflicts | . ",
    "url": "/ModCube.github.io/changelog/#140---2023-09-15",
    
    "relUrl": "/changelog/#140---2023-09-15"
  },"31": {
    "doc": "Changelog",
    "title": "[1.3.0] - 2023-07-20",
    "content": "Added . | Hardware Support . | New thruster models | Additional sensor drivers | Improved hardware abstraction | Hot-pluggable components | . | Software Features . | Automated calibration procedures | Enhanced diagnostics system | Improved logging capabilities | Better error recovery | . | . Changed . | Refactored control architecture | Improved code organization | Enhanced parameter management | Updated build system | . Fixed . | Memory management issues | Thread synchronization problems | Configuration loading bugs | . ",
    "url": "/ModCube.github.io/changelog/#130---2023-07-20",
    
    "relUrl": "/changelog/#130---2023-07-20"
  },"32": {
    "doc": "Changelog",
    "title": "[1.2.0] - 2023-05-10",
    "content": "Added . | Mission Planning . | Waypoint-based navigation | Automated survey patterns | Mission progress tracking | Emergency procedures | . | Visualization Tools . | Real-time 3D visualization | Sensor data plotting | Mission replay capabilities | Performance monitoring | . | . Changed . | Improved user interface design | Enhanced parameter tuning tools | Better integration with external systems | . Fixed . | Navigation accuracy improvements | Sensor synchronization issues | Communication protocol bugs | . ",
    "url": "/ModCube.github.io/changelog/#120---2023-05-10",
    
    "relUrl": "/changelog/#120---2023-05-10"
  },"33": {
    "doc": "Changelog",
    "title": "[1.1.0] - 2023-03-01",
    "content": "Added . | Core Functionality . | Basic autonomous navigation | PID control implementation | Sensor data fusion | Simple mission execution | . | Development Tools . | Simulation environment | Testing framework | Documentation system | Build automation | . | . Changed . | Improved system stability | Enhanced error handling | Better code documentation | . Fixed . | Initial bug fixes and improvements | Performance optimizations | Compatibility issues | . ",
    "url": "/ModCube.github.io/changelog/#110---2023-03-01",
    
    "relUrl": "/changelog/#110---2023-03-01"
  },"34": {
    "doc": "Changelog",
    "title": "[1.0.0] - 2023-01-15",
    "content": "Added . | Initial Release . | Basic vehicle control system | Fundamental sensor integration | Simple simulation environment | Core ROS package structure | . | Features . | Manual control capabilities | Basic telemetry system | Simple configuration management | Initial documentation | . | . Notes . | First stable release | Baseline functionality established | Foundation for future development | . ",
    "url": "/ModCube.github.io/changelog/#100---2023-01-15",
    
    "relUrl": "/changelog/#100---2023-01-15"
  },"35": {
    "doc": "Changelog",
    "title": "Version Numbering",
    "content": "We follow Semantic Versioning (SemVer): . | MAJOR version when you make incompatible API changes | MINOR version when you add functionality in a backwards compatible manner | PATCH version when you make backwards compatible bug fixes | . ",
    "url": "/ModCube.github.io/changelog/#version-numbering",
    
    "relUrl": "/changelog/#version-numbering"
  },"36": {
    "doc": "Changelog",
    "title": "Release Process",
    "content": "Pre-release Testing . | Automated Testing . | Unit tests must pass | Integration tests must pass | Performance benchmarks must meet criteria | Documentation builds successfully | . | Manual Testing . | Hardware-in-the-loop testing | Real-world scenario validation | User acceptance testing | Regression testing | . | Code Review . | All changes reviewed by maintainers | Security review for critical changes | Performance impact assessment | Documentation review | . | . Release Checklist . | All tests passing | Documentation updated | Changelog updated | Version numbers bumped | Release notes prepared | Migration guide updated (if needed) | Security review completed | Performance benchmarks met | Backward compatibility verified | Hardware compatibility tested | . Release Channels . Stable Releases . | Frequency: Every 3-4 months | Testing: Extensive testing and validation | Support: Long-term support and bug fixes | Audience: Production deployments | . Beta Releases . | Frequency: Monthly | Testing: Automated testing and limited manual testing | Support: Community support | Audience: Early adopters and testers | . Development Builds . | Frequency: Continuous | Testing: Automated testing only | Support: No official support | Audience: Developers and contributors | . ",
    "url": "/ModCube.github.io/changelog/#release-process",
    
    "relUrl": "/changelog/#release-process"
  },"37": {
    "doc": "Changelog",
    "title": "Migration Guides",
    "content": "Upgrading from 1.x to 2.x . See Migration Guide v2.0 for detailed instructions. Key Changes: . | Package structure reorganization | Updated message definitions | New configuration format | API changes | . Migration Steps: . | Backup current configuration | Update package dependencies | Run migration script | Update custom code | Test thoroughly | . Upgrading from 2.0 to 2.1 . Backward Compatible Changes: . | New features are additive | Existing APIs remain unchanged | Configuration files are compatible | No breaking changes | . Recommended Actions: . | Update to latest version | Review new features | Update documentation | Consider adopting new capabilities | . ",
    "url": "/ModCube.github.io/changelog/#migration-guides",
    
    "relUrl": "/changelog/#migration-guides"
  },"38": {
    "doc": "Changelog",
    "title": "Support Policy",
    "content": "Long-Term Support (LTS) . | LTS Versions: 2.0.x, 1.5.x | Support Duration: 2 years from release | Support Type: Security fixes and critical bug fixes | Upgrade Path: Clear migration guides provided | . Regular Releases . | Support Duration: Until next minor release | Support Type: Bug fixes and minor improvements | Frequency: Every 3-4 months | . End of Life (EOL) . | Notice Period: 6 months advance notice | Final Support: Security fixes only | Migration Support: Documentation and tools provided | . ",
    "url": "/ModCube.github.io/changelog/#support-policy",
    
    "relUrl": "/changelog/#support-policy"
  },"39": {
    "doc": "Changelog",
    "title": "Contributing to Releases",
    "content": "Feature Requests . | Proposal: Submit feature request issue | Discussion: Community discussion and feedback | Planning: Include in release planning | Implementation: Develop and test feature | Review: Code review and validation | Integration: Merge into development branch | . Bug Reports . | Report: Submit detailed bug report | Triage: Assess severity and priority | Assignment: Assign to appropriate developer | Fix: Develop and test fix | Validation: Verify fix resolves issue | Release: Include in next appropriate release | . Release Notes . Each release includes: . | Summary: High-level overview of changes | New Features: Detailed description of additions | Improvements: Performance and usability enhancements | Bug Fixes: List of resolved issues | Breaking Changes: API or behavior changes | Migration Guide: Instructions for upgrading | Known Issues: Current limitations or problems | Acknowledgments: Contributors and supporters | . Note: This changelog is automatically updated with each release. For the most current information, check the GitHub Releases page. ",
    "url": "/ModCube.github.io/changelog/#contributing-to-releases",
    
    "relUrl": "/changelog/#contributing-to-releases"
  },"40": {
    "doc": "Contributing",
    "title": "Contributing to RS-ModCubes",
    "content": "We welcome contributions to the RS-ModCubes project! This guide will help you understand how to contribute effectively to our open-source underwater robotics platform. ",
    "url": "/ModCube.github.io/contributing/#contributing-to-rs-modcubes",
    
    "relUrl": "/contributing/#contributing-to-rs-modcubes"
  },"41": {
    "doc": "Contributing",
    "title": "Table of Contents",
    "content": ". | Getting Started | Development Environment | Contribution Types | Development Workflow | Coding Standards | Testing Guidelines | Documentation | Pull Request Process | Community Guidelines | Recognition | . ",
    "url": "/ModCube.github.io/contributing/#table-of-contents",
    
    "relUrl": "/contributing/#table-of-contents"
  },"42": {
    "doc": "Contributing",
    "title": "Getting Started",
    "content": "Prerequisites . Before contributing, ensure you have: . | Git installed and configured | GitHub account with SSH keys set up | ROS development environment (Melodic or Noetic) | Basic understanding of underwater robotics concepts | Familiarity with C++ and Python programming | . First Steps . | Fork the repository on GitHub | Clone your fork locally: git clone git@github.com:YOUR_USERNAME/RS-ModCubes.git cd RS-ModCubes . | Add upstream remote: git remote add upstream git@github.com:ORIGINAL_OWNER/RS-ModCubes.git . | Set up development environment following the Installation Guide | . ",
    "url": "/ModCube.github.io/contributing/#getting-started",
    
    "relUrl": "/contributing/#getting-started"
  },"43": {
    "doc": "Contributing",
    "title": "Development Environment",
    "content": "Required Tools . # Install development tools sudo apt install -y \\ build-essential \\ cmake \\ git \\ python3-pip \\ clang-format \\ cppcheck \\ valgrind # Install Python tools pip3 install --user \\ pre-commit \\ black \\ flake8 \\ pytest \\ sphinx . IDE Setup . Recommended IDEs with ROS support: . | VS Code with ROS extension | CLion with ROS plugin | Qt Creator with ROS plugin | Vim/Neovim with appropriate plugins | . Pre-commit Hooks . Set up pre-commit hooks to ensure code quality: . # Install pre-commit pip3 install pre-commit # Install hooks pre-commit install # Run hooks manually pre-commit run --all-files . ",
    "url": "/ModCube.github.io/contributing/#development-environment",
    
    "relUrl": "/contributing/#development-environment"
  },"44": {
    "doc": "Contributing",
    "title": "Contribution Types",
    "content": "We welcome various types of contributions: . Code Contributions . | Bug fixes: Fix existing issues | New features: Add functionality | Performance improvements: Optimize existing code | Hardware support: Add new sensor/actuator drivers | Algorithm implementations: Add new control or estimation algorithms | . Documentation . | API documentation: Document functions and classes | Tutorials: Create step-by-step guides | Examples: Provide usage examples | Wiki articles: Write explanatory content | Translation: Translate documentation to other languages | . Testing . | Unit tests: Test individual components | Integration tests: Test component interactions | Hardware tests: Test with real hardware | Performance benchmarks: Measure system performance | . Community . | Issue reporting: Report bugs and suggest features | Issue triaging: Help categorize and prioritize issues | Code review: Review pull requests | Community support: Help other users | . ",
    "url": "/ModCube.github.io/contributing/#contribution-types",
    
    "relUrl": "/contributing/#contribution-types"
  },"45": {
    "doc": "Contributing",
    "title": "Development Workflow",
    "content": "Branch Strategy . We use a Git flow-based branching strategy: . | main: Stable release branch | develop: Integration branch for new features | feature/: Feature development branches | bugfix/: Bug fix branches | hotfix/: Critical fixes for main branch | . Creating a Feature Branch . # Update your fork git checkout develop git pull upstream develop # Create feature branch git checkout -b feature/your-feature-name # Make your changes # ... # Commit changes git add . git commit -m \"Add your feature description\" # Push to your fork git push origin feature/your-feature-name . Keeping Your Branch Updated . # Fetch latest changes git fetch upstream # Rebase your branch git rebase upstream/develop # Force push if needed (be careful!) git push --force-with-lease origin feature/your-feature-name . ",
    "url": "/ModCube.github.io/contributing/#development-workflow",
    
    "relUrl": "/contributing/#development-workflow"
  },"46": {
    "doc": "Contributing",
    "title": "Coding Standards",
    "content": "C++ Guidelines . We follow the ROS C++ Style Guide with some modifications: . Naming Conventions . // Classes: PascalCase class VehicleController { public: // Methods: camelCase void updateControl(); // Public members: camelCase double maxThrust; private: // Private members: camelCase with trailing underscore double current_thrust_; // Constants: UPPER_CASE static const double MAX_VELOCITY; }; // Functions: camelCase void calculateTrajectory(); // Variables: snake_case double target_depth = -5.0; // Namespaces: lowercase namespace modcube_control { // ... } . Code Formatting . Use clang-format with our configuration: . # Format single file clang-format -i src/controller.cpp # Format all C++ files find . -name '*.cpp' -o -name '*.h' | xargs clang-format -i . Header Structure . /** * @file vehicle_controller.h * @brief Vehicle control system implementation * @author Your Name * @date 2024-01-01 */ #ifndef MODCUBE_CONTROL_VEHICLE_CONTROLLER_H #define MODCUBE_CONTROL_VEHICLE_CONTROLLER_H #include &lt;ros/ros.h&gt; #include &lt;geometry_msgs/Twist.h&gt; namespace modcube_control { /** * @brief Vehicle controller class * * Detailed description of the class functionality. */ class VehicleController { public: /** * @brief Constructor * @param nh ROS node handle */ explicit VehicleController(ros::NodeHandle&amp; nh); /** * @brief Update control output * @param target_twist Desired velocity * @return Control success status */ bool updateControl(const geometry_msgs::Twist&amp; target_twist); private: ros::NodeHandle nh_; ros::Publisher cmd_pub_; }; } // namespace modcube_control #endif // MODCUBE_CONTROL_VEHICLE_CONTROLLER_H . Python Guidelines . We follow PEP 8 with some ROS-specific conventions: . Code Style . #!/usr/bin/env python3 \"\"\" Vehicle Controller Module This module implements the main vehicle control system. Author: Your Name Date: 2024-01-01 \"\"\" import rospy import numpy as np from geometry_msgs.msg import Twist from modcube_msgs.msg import ControllerCommand class VehicleController: \"\"\"Vehicle controller class. This class implements PID control for underwater vehicles. Attributes: node_name (str): ROS node name control_rate (float): Control loop frequency in Hz \"\"\" def __init__(self, node_name='vehicle_controller'): \"\"\"Initialize the vehicle controller. Args: node_name (str): Name of the ROS node \"\"\" self.node_name = node_name self.control_rate = 50.0 # Hz # Initialize ROS rospy.init_node(self.node_name) # Publishers and subscribers self.cmd_pub = rospy.Publisher( '/modcube/cmd_vel', Twist, queue_size=10 ) def update_control(self, target_twist): \"\"\"Update control output. Args: target_twist (Twist): Desired velocity Returns: bool: True if control update successful \"\"\" try: # Control logic here self.cmd_pub.publish(target_twist) return True except Exception as e: rospy.logerr(f\"Control update failed: {e}\") return False def main(): \"\"\"Main function.\"\"\" try: controller = VehicleController() rospy.spin() except rospy.ROSInterruptException: pass if __name__ == '__main__': main() . Code Formatting . Use black for Python code formatting: . # Format single file black src/controller.py # Format all Python files black . # Check formatting black --check . ROS-Specific Guidelines . Package Structure . modcube_package/ ├── CMakeLists.txt ├── package.xml ├── README.md ├── include/ │ └── modcube_package/ │ └── header.h ├── src/ │ ├── cpp_source.cpp │ └── python_script.py ├── scripts/ │ └── executable_script.py ├── launch/ │ └── package.launch ├── config/ │ └── parameters.yaml ├── msg/ │ └── CustomMessage.msg ├── srv/ │ └── CustomService.srv └── test/ ├── test_cpp.cpp └── test_python.py . Launch Files . &lt;?xml version=\"1.0\"?&gt; &lt;launch&gt; &lt;!-- Arguments --&gt; &lt;arg name=\"vehicle_name\" default=\"modcube\"/&gt; &lt;arg name=\"debug\" default=\"false\"/&gt; &lt;!-- Parameters --&gt; &lt;rosparam file=\"$(find modcube_config)/config/controller.yaml\" command=\"load\"/&gt; &lt;!-- Nodes --&gt; &lt;node name=\"vehicle_controller\" pkg=\"modcube_control\" type=\"vehicle_controller_node\" output=\"screen\" if=\"$(arg debug)\"&gt; &lt;param name=\"vehicle_name\" value=\"$(arg vehicle_name)\"/&gt; &lt;/node&gt; &lt;!-- Include other launch files --&gt; &lt;include file=\"$(find modcube_sensors)/launch/sensors.launch\"&gt; &lt;arg name=\"vehicle_name\" value=\"$(arg vehicle_name)\"/&gt; &lt;/include&gt; &lt;/launch&gt; . ",
    "url": "/ModCube.github.io/contributing/#coding-standards",
    
    "relUrl": "/contributing/#coding-standards"
  },"47": {
    "doc": "Contributing",
    "title": "Testing Guidelines",
    "content": "Unit Testing . C++ Tests (Google Test) . #include &lt;gtest/gtest.h&gt; #include &lt;modcube_control/vehicle_controller.h&gt; class VehicleControllerTest : public ::testing::Test { protected: void SetUp() override { // Test setup } void TearDown() override { // Test cleanup } modcube_control::VehicleController controller_; }; TEST_F(VehicleControllerTest, InitializationTest) { // Test controller initialization EXPECT_TRUE(controller_.isInitialized()); } TEST_F(VehicleControllerTest, ControlUpdateTest) { geometry_msgs::Twist target; target.linear.x = 1.0; EXPECT_TRUE(controller_.updateControl(target)); } int main(int argc, char** argv) { testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); } . Python Tests (pytest) . import pytest import rospy from modcube_control.vehicle_controller import VehicleController class TestVehicleController: \"\"\"Test cases for VehicleController class.\"\"\" def setup_method(self): \"\"\"Set up test fixtures.\"\"\" self.controller = VehicleController() def test_initialization(self): \"\"\"Test controller initialization.\"\"\" assert self.controller.node_name == 'vehicle_controller' assert self.controller.control_rate == 50.0 def test_control_update(self): \"\"\"Test control update functionality.\"\"\" from geometry_msgs.msg import Twist target = Twist() target.linear.x = 1.0 result = self.controller.update_control(target) assert result is True @pytest.mark.parametrize(\"velocity\", [0.0, 1.0, -1.0, 2.5]) def test_velocity_range(self, velocity): \"\"\"Test different velocity values.\"\"\" from geometry_msgs.msg import Twist target = Twist() target.linear.x = velocity result = self.controller.update_control(target) assert result is True . Integration Testing . #!/usr/bin/env python3 \"\"\" Integration test for vehicle control system. \"\"\" import unittest import rospy import rostest from geometry_msgs.msg import Twist from nav_msgs.msg import Odometry class VehicleControlIntegrationTest(unittest.TestCase): \"\"\"Integration test for vehicle control.\"\"\" def setUp(self): \"\"\"Set up test environment.\"\"\" rospy.init_node('vehicle_control_test') self.cmd_pub = rospy.Publisher('/modcube/cmd_vel', Twist, queue_size=1) self.odom_sub = rospy.Subscriber('/modcube/odom', Odometry, self.odom_callback) self.latest_odom = None # Wait for connections rospy.sleep(1.0) def odom_callback(self, msg): \"\"\"Handle odometry messages.\"\"\" self.latest_odom = msg def test_forward_motion(self): \"\"\"Test forward motion command.\"\"\" # Send forward command cmd = Twist() cmd.linear.x = 1.0 self.cmd_pub.publish(cmd) # Wait for response timeout = rospy.Time.now() + rospy.Duration(5.0) while self.latest_odom is None and rospy.Time.now() &lt; timeout: rospy.sleep(0.1) # Check that vehicle is moving forward self.assertIsNotNone(self.latest_odom) self.assertGreater(self.latest_odom.twist.twist.linear.x, 0.1) if __name__ == '__main__': rostest.rosrun('modcube_control', 'vehicle_control_integration_test', VehicleControlIntegrationTest) . Running Tests . # Run C++ tests catkin_make run_tests_modcube_control # Run Python tests python -m pytest src/modcube_control/test/ # Run ROS tests rostest modcube_control vehicle_control_test.test # Run all tests catkin_make run_tests . ",
    "url": "/ModCube.github.io/contributing/#testing-guidelines",
    
    "relUrl": "/contributing/#testing-guidelines"
  },"48": {
    "doc": "Contributing",
    "title": "Documentation",
    "content": "Code Documentation . Doxygen for C++ . /** * @brief Calculate PID control output * * This function computes the PID control output based on the error * between the setpoint and current value. * * @param setpoint Desired value * @param current_value Current measured value * @param dt Time step in seconds * @return Control output value * * @note This function assumes that the PID gains have been properly set * @warning Large time steps may cause instability * * @see setPIDGains() * @since Version 1.0 */ double calculatePID(double setpoint, double current_value, double dt); . Docstrings for Python . def calculate_pid(self, setpoint, current_value, dt): \"\"\"Calculate PID control output. This function computes the PID control output based on the error between the setpoint and current value. Args: setpoint (float): Desired value current_value (float): Current measured value dt (float): Time step in seconds Returns: float: Control output value Raises: ValueError: If dt is negative or zero Note: This function assumes that the PID gains have been properly set. Warning: Large time steps may cause instability. Example: &gt;&gt;&gt; controller = PIDController() &gt;&gt;&gt; output = controller.calculate_pid(1.0, 0.8, 0.02) &gt;&gt;&gt; print(f\"Control output: {output}\") \"\"\" if dt &lt;= 0: raise ValueError(\"Time step must be positive\") # PID calculation logic pass . README Files . Each package should have a comprehensive README: . # ModCube Control This package provides control algorithms for the ModCube underwater vehicle. ## Overview The control system implements various control strategies including: - PID control for position and velocity - Adaptive control for changing conditions - Formation control for multi-vehicle operations ## Installation ```bash # Clone repository git clone https://github.com/your-org/RS-ModCubes.git # Build package catkin_make . ",
    "url": "/ModCube.github.io/contributing/#documentation-1",
    
    "relUrl": "/contributing/#documentation-1"
  },"49": {
    "doc": "Contributing",
    "title": "Usage",
    "content": "Basic Control . # Launch control system roslaunch modcube_control vehicle_control.launch # Send velocity command rostopic pub /modcube/cmd_vel geometry_msgs/Twist \"linear: {x: 1.0}\" . Configuration . Edit config/controller.yaml to adjust control parameters: . controller: pid_gains: position: x: {p: 2.0, i: 0.1, d: 0.5} . ",
    "url": "/ModCube.github.io/contributing/#usage",
    
    "relUrl": "/contributing/#usage"
  },"50": {
    "doc": "Contributing",
    "title": "API Reference",
    "content": "Classes . | VehicleController: Main control class | PIDController: PID control implementation | . Topics . | /modcube/cmd_vel (geometry_msgs/Twist): Velocity commands | /modcube/odom (nav_msgs/Odometry): Vehicle odometry | . Services . | /modcube/set_pid_gains: Update PID parameters | . ",
    "url": "/ModCube.github.io/contributing/#api-reference",
    
    "relUrl": "/contributing/#api-reference"
  },"51": {
    "doc": "Contributing",
    "title": "Testing",
    "content": "# Run unit tests catkin_make run_tests_modcube_control # Run integration tests rostest modcube_control integration_test.test . ",
    "url": "/ModCube.github.io/contributing/#testing-1",
    
    "relUrl": "/contributing/#testing-1"
  },"52": {
    "doc": "Contributing",
    "title": "Contributing",
    "content": "See CONTRIBUTING.md for contribution guidelines. ",
    "url": "/ModCube.github.io/contributing/",
    
    "relUrl": "/contributing/"
  },"53": {
    "doc": "Contributing",
    "title": "License",
    "content": "This project is licensed under the MIT License - see LICENSE for details. ## Pull Request Process ### Before Submitting 1. **Test your changes** thoroughly 2. **Update documentation** as needed 3. **Follow coding standards** 4. **Write descriptive commit messages** 5. **Rebase on latest develop branch** ### Pull Request Template Use this template for your pull requests: ```markdown ## Description Brief description of the changes made. ## Type of Change - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected) - [ ] Documentation update ## Testing - [ ] Unit tests pass - [ ] Integration tests pass - [ ] Manual testing completed - [ ] Hardware testing completed (if applicable) ## Checklist - [ ] My code follows the style guidelines - [ ] I have performed a self-review of my code - [ ] I have commented my code, particularly in hard-to-understand areas - [ ] I have made corresponding changes to the documentation - [ ] My changes generate no new warnings - [ ] I have added tests that prove my fix is effective or that my feature works - [ ] New and existing unit tests pass locally with my changes ## Screenshots (if applicable) Add screenshots to help explain your changes. ## Additional Notes Any additional information that reviewers should know. Review Process . | Automated checks must pass (CI/CD) | Code review by at least one maintainer | Testing in simulation and hardware (if applicable) | Documentation review | Final approval and merge | . ",
    "url": "/ModCube.github.io/contributing/#license",
    
    "relUrl": "/contributing/#license"
  },"54": {
    "doc": "Contributing",
    "title": "Community Guidelines",
    "content": "Code of Conduct . We are committed to providing a welcoming and inclusive environment. Please: . | Be respectful and considerate | Be collaborative and helpful | Be patient with newcomers | Focus on constructive feedback | Respect different viewpoints | . Communication Channels . | GitHub Issues: Bug reports and feature requests | GitHub Discussions: General questions and discussions | Slack/Discord: Real-time communication (if available) | Mailing List: Announcements and important updates | . Getting Help . If you need help: . | Check documentation first | Search existing issues on GitHub | Ask in discussions or community channels | Create a new issue if needed | . ",
    "url": "/ModCube.github.io/contributing/#community-guidelines",
    
    "relUrl": "/contributing/#community-guidelines"
  },"55": {
    "doc": "Contributing",
    "title": "Recognition",
    "content": "We value all contributions and recognize contributors through: . Contributors List . All contributors are listed in: . | CONTRIBUTORS.md file | GitHub contributors page | Release notes | . Contribution Types . We recognize various contribution types: . | 💻 Code | 📖 Documentation | 🐛 Bug reports | 💡 Ideas | 🤔 Answering questions | ⚠️ Tests | 🔧 Tools | 🌍 Translation | . Special Recognition . | Maintainer status for consistent, high-quality contributions | Featured contributions in release announcements | Conference presentations opportunities | Academic collaboration for research contributions | . ",
    "url": "/ModCube.github.io/contributing/#recognition",
    
    "relUrl": "/contributing/#recognition"
  },"56": {
    "doc": "Contributing",
    "title": "Development Roadmap",
    "content": "Current Priorities . | Performance optimization | Hardware driver expansion | Advanced control algorithms | Multi-vehicle coordination | Machine learning integration | . How to Get Involved . | Check the roadmap for current priorities | Look for “good first issue” labels | Join planning discussions | Propose new features | . ",
    "url": "/ModCube.github.io/contributing/#development-roadmap",
    
    "relUrl": "/contributing/#development-roadmap"
  },"57": {
    "doc": "Contributing",
    "title": "Resources",
    "content": "Learning Materials . | ROS Tutorials | Underwater Robotics Handbook | Control Systems Theory | Git Workflow Guide | . Tools and References . | ROS Style Guide | Google C++ Style Guide | PEP 8 Python Style Guide | Conventional Commits | . Thank you for contributing to RS-ModCubes! Your efforts help advance underwater robotics research and applications worldwide. ",
    "url": "/ModCube.github.io/contributing/#resources",
    
    "relUrl": "/contributing/#resources"
  },"58": {
    "doc": "Examples",
    "title": "Examples",
    "content": "This section provides practical examples and use cases for the RS-ModCubes system, demonstrating various capabilities from basic operations to advanced applications. ",
    "url": "/ModCube.github.io/examples/",
    
    "relUrl": "/examples/"
  },"59": {
    "doc": "Examples",
    "title": "Table of Contents",
    "content": ". | Basic Operations | Navigation Examples | Mission Planning | Sensor Integration | Multi-Vehicle Coordination | Advanced Applications | Custom Development | . ",
    "url": "/ModCube.github.io/examples/#table-of-contents",
    
    "relUrl": "/examples/#table-of-contents"
  },"60": {
    "doc": "Examples",
    "title": "Basic Operations",
    "content": "Example 1: Simple Position Control . This example demonstrates basic position control of the ModCube vehicle. #!/usr/bin/env python \"\"\" Basic Position Control Example This script demonstrates how to control the ModCube vehicle to move to specific positions in 3D space. \"\"\" import rospy import time from geometry_msgs.msg import Point, Quaternion from modcube_msgs.msg import ControllerCommand class BasicPositionController: def __init__(self): rospy.init_node('basic_position_controller') # Publisher for controller commands self.cmd_pub = rospy.Publisher('/modcube/controller_command', ControllerCommand, queue_size=10) # Wait for publisher to be ready rospy.sleep(1.0) def goto_position(self, x, y, z, yaw=0.0): \"\"\"Move to specified position with optional yaw angle.\"\"\" cmd = ControllerCommand() cmd.header.stamp = rospy.Time.now() cmd.header.frame_id = 'odom' cmd.mode = 1 # Position control mode # Set target position cmd.setpoint.position = Point(x, y, z) # Convert yaw to quaternion cmd.setpoint.orientation = self.yaw_to_quaternion(yaw) # Publish command self.cmd_pub.publish(cmd) rospy.loginfo(f\"Moving to position: ({x}, {y}, {z}) with yaw: {yaw}\") def yaw_to_quaternion(self, yaw): \"\"\"Convert yaw angle to quaternion.\"\"\" import math return Quaternion( x=0.0, y=0.0, z=math.sin(yaw / 2.0), w=math.cos(yaw / 2.0) ) def run_demo(self): \"\"\"Run a demonstration sequence.\"\"\" rospy.loginfo(\"Starting basic position control demo\") # Define waypoints waypoints = [ (0, 0, -1, 0), # Start position (5, 0, -1, 0), # Move forward (5, 5, -1, 1.57), # Move right and turn (0, 5, -1, 3.14), # Move back and turn (0, 0, -1, 0), # Return to start ] for wp in waypoints: self.goto_position(wp[0], wp[1], wp[2], wp[3]) time.sleep(10) # Wait 10 seconds at each waypoint rospy.loginfo(\"Demo completed\") if __name__ == '__main__': try: controller = BasicPositionController() controller.run_demo() except rospy.ROSInterruptException: pass . Example 2: Velocity Control . This example shows how to control the vehicle using velocity commands. #!/usr/bin/env python \"\"\" Velocity Control Example Demonstrates velocity-based control for smooth motion patterns. \"\"\" import rospy import math from geometry_msgs.msg import Vector3 from modcube_msgs.msg import ControllerCommand class VelocityController: def __init__(self): rospy.init_node('velocity_controller') self.cmd_pub = rospy.Publisher('/modcube/controller_command', ControllerCommand, queue_size=10) rospy.sleep(1.0) def set_velocity(self, vx, vy, vz, wx=0.0, wy=0.0, wz=0.0): \"\"\"Set linear and angular velocities.\"\"\" cmd = ControllerCommand() cmd.header.stamp = rospy.Time.now() cmd.header.frame_id = 'base_link' cmd.mode = 2 # Velocity control mode cmd.setpoint.linear = Vector3(vx, vy, vz) cmd.setpoint.angular = Vector3(wx, wy, wz) self.cmd_pub.publish(cmd) def circle_pattern(self, radius=2.0, speed=0.5, duration=30.0): \"\"\"Execute a circular motion pattern.\"\"\" rospy.loginfo(f\"Starting circular pattern: radius={radius}m, speed={speed}m/s\") rate = rospy.Rate(10) # 10 Hz start_time = rospy.Time.now() while (rospy.Time.now() - start_time).to_sec() &lt; duration: # Calculate angular velocity for circular motion angular_vel = speed / radius # Set forward velocity and yaw rate self.set_velocity(vx=speed, vy=0.0, vz=0.0, wz=angular_vel) rate.sleep() # Stop motion self.set_velocity(0, 0, 0, 0, 0, 0) rospy.loginfo(\"Circular pattern completed\") def figure_eight(self, size=3.0, speed=0.3, cycles=2): \"\"\"Execute a figure-eight pattern.\"\"\" rospy.loginfo(f\"Starting figure-eight pattern: size={size}m, speed={speed}m/s\") rate = rospy.Rate(20) # 20 Hz for cycle in range(cycles): # Each cycle takes 2π seconds cycle_duration = 2 * math.pi / speed * size steps = int(cycle_duration * 20) # 20 Hz for step in range(steps): t = step / 20.0 # Time in seconds # Figure-eight parametric equations vx = speed * math.cos(t / size) vy = speed * math.sin(2 * t / size) wz = (-math.sin(t / size) + 2 * math.cos(2 * t / size)) / size self.set_velocity(vx, vy, 0.0, 0.0, 0.0, wz) rate.sleep() # Stop motion self.set_velocity(0, 0, 0, 0, 0, 0) rospy.loginfo(\"Figure-eight pattern completed\") if __name__ == '__main__': try: controller = VelocityController() # Execute different patterns controller.circle_pattern(radius=3.0, speed=0.5, duration=20.0) rospy.sleep(2.0) controller.figure_eight(size=2.0, speed=0.3, cycles=2) except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#basic-operations",
    
    "relUrl": "/examples/#basic-operations"
  },"61": {
    "doc": "Examples",
    "title": "Navigation Examples",
    "content": "Example 3: Waypoint Navigation with Obstacle Avoidance . #!/usr/bin/env python \"\"\" Waypoint Navigation with Obstacle Avoidance Demonstrates autonomous navigation between waypoints while avoiding obstacles. \"\"\" import rospy import numpy as np from geometry_msgs.msg import Point, Quaternion from sensor_msgs.msg import PointCloud2 from modcube_msgs.msg import ControllerCommand, NavState from modcube_common.motion import MotionClient from modcube_common.planning import PathPlanner class WaypointNavigator: def __init__(self): rospy.init_node('waypoint_navigator') # Initialize motion client and path planner self.motion_client = MotionClient() self.path_planner = PathPlanner() # Subscribers self.nav_sub = rospy.Subscriber('/modcube/nav_state', NavState, self.nav_callback) self.cloud_sub = rospy.Subscriber('/modcube/pointcloud', PointCloud2, self.cloud_callback) # Current state self.current_pose = None self.obstacles = [] rospy.sleep(1.0) def nav_callback(self, msg): \"\"\"Update current pose.\"\"\" self.current_pose = msg.pose.pose def cloud_callback(self, msg): \"\"\"Process point cloud for obstacle detection.\"\"\" # Simple obstacle detection (in practice, use more sophisticated methods) self.obstacles = self.extract_obstacles(msg) def extract_obstacles(self, pointcloud): \"\"\"Extract obstacle positions from point cloud.\"\"\" # Simplified obstacle extraction # In practice, use clustering, filtering, etc. obstacles = [] # Convert point cloud to numpy array (simplified) # points = pointcloud_to_array(pointcloud) # # for point in points: # if self.is_obstacle(point): # obstacles.append(point) return obstacles def navigate_waypoints(self, waypoints, avoid_obstacles=True): \"\"\"Navigate through a list of waypoints.\"\"\" rospy.loginfo(f\"Starting navigation through {len(waypoints)} waypoints\") for i, waypoint in enumerate(waypoints): rospy.loginfo(f\"Navigating to waypoint {i+1}: {waypoint}\") if avoid_obstacles and self.obstacles: # Plan path around obstacles path = self.path_planner.plan_path( start=self.current_pose, goal=waypoint, obstacles=self.obstacles ) if path: success = self.motion_client.follow_trajectory(path) else: rospy.logwarn(\"No valid path found, attempting direct navigation\") success = self.motion_client.goto_pose(waypoint) else: # Direct navigation success = self.motion_client.goto_pose(waypoint) if success: rospy.loginfo(f\"Reached waypoint {i+1}\") else: rospy.logwarn(f\"Failed to reach waypoint {i+1}\") break rospy.loginfo(\"Waypoint navigation completed\") def run_demo(self): \"\"\"Run navigation demo.\"\"\" # Define waypoints waypoints = [ self.create_pose(5, 0, -2, 0), self.create_pose(10, 5, -2, 1.57), self.create_pose(5, 10, -2, 3.14), self.create_pose(0, 5, -2, -1.57), self.create_pose(0, 0, -2, 0), ] self.navigate_waypoints(waypoints, avoid_obstacles=True) def create_pose(self, x, y, z, yaw): \"\"\"Create a pose from position and yaw.\"\"\" from geometry_msgs.msg import Pose import math pose = Pose() pose.position = Point(x, y, z) pose.orientation = Quaternion( x=0.0, y=0.0, z=math.sin(yaw / 2.0), w=math.cos(yaw / 2.0) ) return pose if __name__ == '__main__': try: navigator = WaypointNavigator() navigator.run_demo() except rospy.ROSInterruptException: pass . Example 4: Dynamic Target Tracking . #!/usr/bin/env python \"\"\" Dynamic Target Tracking Tracks and follows a moving target using visual detection. \"\"\" import rospy import math from geometry_msgs.msg import Point, Twist from modcube_msgs.msg import AprilTagDetection, ControllerCommand from modcube_common.vision import TargetTracker class TargetFollower: def __init__(self): rospy.init_node('target_follower') # Target tracking self.target_tracker = TargetTracker() self.target_position = None self.target_velocity = None # Control parameters self.follow_distance = 3.0 # meters self.max_speed = 1.0 # m/s # Publishers and subscribers self.cmd_pub = rospy.Publisher('/modcube/controller_command', ControllerCommand, queue_size=10) self.detection_sub = rospy.Subscriber('/modcube/apriltag_detections', AprilTagDetection, self.detection_callback) # Control timer self.control_timer = rospy.Timer(rospy.Duration(0.1), self.control_callback) rospy.loginfo(\"Target follower initialized\") def detection_callback(self, msg): \"\"\"Process target detection.\"\"\" if msg.id == 1: # Follow AprilTag with ID 1 # Update target position self.target_position = msg.pose.pose.position # Estimate target velocity (simple differentiation) if hasattr(self, 'last_target_pos') and hasattr(self, 'last_detection_time'): dt = (msg.header.stamp - self.last_detection_time).to_sec() if dt &gt; 0: dx = self.target_position.x - self.last_target_pos.x dy = self.target_position.y - self.last_target_pos.y dz = self.target_position.z - self.last_target_pos.z self.target_velocity = Point( x=dx / dt, y=dy / dt, z=dz / dt ) self.last_target_pos = self.target_position self.last_detection_time = msg.header.stamp def control_callback(self, event): \"\"\"Main control loop.\"\"\" if self.target_position is None: return # Predict target future position prediction_time = 1.0 # seconds predicted_pos = self.predict_target_position(prediction_time) # Calculate desired following position follow_pos = self.calculate_follow_position(predicted_pos) # Generate control command cmd = self.generate_control_command(follow_pos) # Publish command self.cmd_pub.publish(cmd) def predict_target_position(self, dt): \"\"\"Predict target position after time dt.\"\"\" if self.target_velocity is None: return self.target_position predicted = Point( x=self.target_position.x + self.target_velocity.x * dt, y=self.target_position.y + self.target_velocity.y * dt, z=self.target_position.z + self.target_velocity.z * dt ) return predicted def calculate_follow_position(self, target_pos): \"\"\"Calculate desired following position.\"\"\" # Follow at a fixed distance behind the target # Assume target is moving in XY plane if self.target_velocity and (self.target_velocity.x**2 + self.target_velocity.y**2) &gt; 0.1: # Target is moving, follow behind vel_mag = math.sqrt(self.target_velocity.x**2 + self.target_velocity.y**2) vel_unit_x = -self.target_velocity.x / vel_mag vel_unit_y = -self.target_velocity.y / vel_mag follow_pos = Point( x=target_pos.x + vel_unit_x * self.follow_distance, y=target_pos.y + vel_unit_y * self.follow_distance, z=target_pos.z ) else: # Target is stationary, maintain current relative position follow_pos = Point( x=target_pos.x - self.follow_distance, y=target_pos.y, z=target_pos.z ) return follow_pos def generate_control_command(self, desired_pos): \"\"\"Generate control command to reach desired position.\"\"\" cmd = ControllerCommand() cmd.header.stamp = rospy.Time.now() cmd.header.frame_id = 'odom' cmd.mode = 1 # Position control cmd.setpoint.position = desired_pos # Face towards target if self.target_position: dx = self.target_position.x - desired_pos.x dy = self.target_position.y - desired_pos.y yaw = math.atan2(dy, dx) cmd.setpoint.orientation = self.yaw_to_quaternion(yaw) return cmd def yaw_to_quaternion(self, yaw): \"\"\"Convert yaw to quaternion.\"\"\" from geometry_msgs.msg import Quaternion return Quaternion( x=0.0, y=0.0, z=math.sin(yaw / 2.0), w=math.cos(yaw / 2.0) ) if __name__ == '__main__': try: follower = TargetFollower() rospy.spin() except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#navigation-examples",
    
    "relUrl": "/examples/#navigation-examples"
  },"62": {
    "doc": "Examples",
    "title": "Mission Planning",
    "content": "Example 5: Search and Rescue Mission . #!/usr/bin/env python \"\"\" Search and Rescue Mission Implements a comprehensive search and rescue operation with pattern search, target detection, and recovery procedures. \"\"\" import rospy import numpy as np from geometry_msgs.msg import Point, Pose from modcube_msgs.msg import MissionState, AprilTagDetection from modcube_mission import BaseMission from modcube_common.motion import MotionClient from modcube_common.planning import SearchPlanner class SearchRescueMission(BaseMission): def __init__(self): super().__init__() self.motion_client = MotionClient() self.search_planner = SearchPlanner() # Mission parameters self.search_area = { 'min_x': 0, 'max_x': 20, 'min_y': 0, 'max_y': 20, 'depth': -3.0 } self.search_pattern = 'lawnmower' self.search_spacing = 2.0 self.search_speed = 0.5 # Target detection self.targets_found = [] self.current_target = None # Subscribers self.detection_sub = rospy.Subscriber('/modcube/apriltag_detections', AprilTagDetection, self.detection_callback) rospy.loginfo(\"Search and Rescue mission initialized\") def detection_callback(self, msg): \"\"\"Handle target detection.\"\"\" if msg.id not in [t['id'] for t in self.targets_found]: target = { 'id': msg.id, 'position': msg.pose.pose.position, 'detection_time': rospy.Time.now(), 'confidence': msg.confidence } self.targets_found.append(target) rospy.loginfo(f\"New target detected: ID {msg.id} at {msg.pose.pose.position}\") def execute(self): \"\"\"Execute the search and rescue mission.\"\"\" rospy.loginfo(\"Starting Search and Rescue mission\") try: # Phase 1: Search phase self.update_state('searching') search_success = self.execute_search_phase() if not search_success: self.update_state('failed') return False # Phase 2: Investigation phase if self.targets_found: self.update_state('investigating') investigation_success = self.execute_investigation_phase() if not investigation_success: self.update_state('failed') return False # Phase 3: Recovery phase if self.targets_found: self.update_state('recovering') recovery_success = self.execute_recovery_phase() if not recovery_success: self.update_state('failed') return False # Mission completed self.update_state('completed') rospy.loginfo(f\"Mission completed. Found {len(self.targets_found)} targets.\") return True except Exception as e: rospy.logerr(f\"Mission failed with error: {e}\") self.update_state('failed') return False def execute_search_phase(self): \"\"\"Execute systematic search of the area.\"\"\" rospy.loginfo(\"Starting search phase\") # Generate search pattern search_waypoints = self.search_planner.generate_pattern( area=self.search_area, pattern=self.search_pattern, spacing=self.search_spacing ) # Execute search pattern for waypoint in search_waypoints: success = self.motion_client.goto_pose(waypoint) if not success: rospy.logwarn(f\"Failed to reach search waypoint: {waypoint}\") return False # Check for early termination if targets found if len(self.targets_found) &gt;= 3: # Stop after finding 3 targets rospy.loginfo(\"Sufficient targets found, ending search phase\") break rospy.loginfo(f\"Search phase completed. Found {len(self.targets_found)} targets.\") return True def execute_investigation_phase(self): \"\"\"Investigate detected targets for detailed analysis.\"\"\" rospy.loginfo(\"Starting investigation phase\") for target in self.targets_found: rospy.loginfo(f\"Investigating target {target['id']}\") # Move closer to target for detailed inspection investigation_pose = self.calculate_investigation_pose(target['position']) success = self.motion_client.goto_pose(investigation_pose) if success: # Perform detailed inspection inspection_result = self.perform_inspection(target) target['inspection_result'] = inspection_result rospy.loginfo(f\"Target {target['id']} inspection completed\") else: rospy.logwarn(f\"Failed to investigate target {target['id']}\") return True def execute_recovery_phase(self): \"\"\"Execute recovery operations for confirmed targets.\"\"\" rospy.loginfo(\"Starting recovery phase\") # Prioritize targets based on investigation results priority_targets = self.prioritize_targets() for target in priority_targets: if target.get('inspection_result', {}).get('requires_recovery', False): rospy.loginfo(f\"Executing recovery for target {target['id']}\") recovery_success = self.execute_target_recovery(target) if recovery_success: target['recovered'] = True rospy.loginfo(f\"Target {target['id']} successfully recovered\") else: rospy.logwarn(f\"Failed to recover target {target['id']}\") return True def calculate_investigation_pose(self, target_pos): \"\"\"Calculate optimal pose for target investigation.\"\"\" from geometry_msgs.msg import Pose import math # Position 2 meters away from target investigation_distance = 2.0 pose = Pose() pose.position.x = target_pos.x - investigation_distance pose.position.y = target_pos.y pose.position.z = target_pos.z # Face towards target yaw = math.atan2(target_pos.y - pose.position.y, target_pos.x - pose.position.x) pose.orientation.z = math.sin(yaw / 2.0) pose.orientation.w = math.cos(yaw / 2.0) return pose def perform_inspection(self, target): \"\"\"Perform detailed inspection of target.\"\"\" # Simulate inspection process rospy.sleep(5.0) # Inspection time # Mock inspection results inspection_result = { 'target_type': 'survivor' if target['id'] % 2 == 0 else 'debris', 'condition': 'good' if target['confidence'] &gt; 0.8 else 'poor', 'requires_recovery': target['id'] % 2 == 0, 'priority': target['confidence'] } return inspection_result def prioritize_targets(self): \"\"\"Prioritize targets based on inspection results.\"\"\" return sorted(self.targets_found, key=lambda t: t.get('inspection_result', {}).get('priority', 0), reverse=True) def execute_target_recovery(self, target): \"\"\"Execute recovery operation for a specific target.\"\"\" # Simulate recovery operation rospy.loginfo(f\"Deploying recovery mechanism for target {target['id']}\") # Move to recovery position recovery_pose = target['position'] success = self.motion_client.goto_pose(recovery_pose) if success: # Simulate recovery actions rospy.sleep(10.0) # Recovery time return True return False if __name__ == '__main__': try: mission = SearchRescueMission() mission.execute() except rospy.ROSInterruptException: pass . Example 6: Autonomous Inspection Mission . #!/usr/bin/env python \"\"\" Autonomous Inspection Mission Performs detailed inspection of underwater structures using computer vision and structured data collection. \"\"\" import rospy import cv2 import numpy as np from sensor_msgs.msg import Image, PointCloud2 from geometry_msgs.msg import Pose, Point from modcube_msgs.msg import InspectionReport from modcube_mission import BaseMission from modcube_common.vision import DefectDetector from modcube_common.motion import MotionClient from cv_bridge import CvBridge class InspectionMission(BaseMission): def __init__(self): super().__init__() self.motion_client = MotionClient() self.defect_detector = DefectDetector() self.bridge = CvBridge() # Inspection parameters self.inspection_distance = 1.5 # meters from structure self.inspection_speed = 0.2 # m/s self.image_capture_rate = 2.0 # Hz # Data collection self.inspection_data = [] self.defects_found = [] # Publishers and subscribers self.report_pub = rospy.Publisher('/modcube/inspection_report', InspectionReport, queue_size=10) self.image_sub = rospy.Subscriber('/modcube/camera/image_raw', Image, self.image_callback) self.pointcloud_sub = rospy.Subscriber('/modcube/pointcloud', PointCloud2, self.pointcloud_callback) # Image capture timer self.capture_timer = rospy.Timer(rospy.Duration(1.0/self.image_capture_rate), self.capture_callback) rospy.loginfo(\"Inspection mission initialized\") def image_callback(self, msg): \"\"\"Process incoming images for defect detection.\"\"\" try: cv_image = self.bridge.imgmsg_to_cv2(msg, \"bgr8\") # Detect defects in image defects = self.defect_detector.detect_defects(cv_image) if defects: self.process_defects(defects, msg.header) except Exception as e: rospy.logerr(f\"Image processing error: {e}\") def pointcloud_callback(self, msg): \"\"\"Process point cloud data for 3D structure analysis.\"\"\" # Extract 3D structure information structure_data = self.analyze_structure_3d(msg) # Store for inspection report self.inspection_data.append({ 'timestamp': msg.header.stamp, 'structure_data': structure_data }) def capture_callback(self, event): \"\"\"Periodic data capture during inspection.\"\"\" # Capture current pose and sensor data current_pose = self.motion_client.get_current_pose() if current_pose: inspection_point = { 'timestamp': rospy.Time.now(), 'pose': current_pose, 'data_captured': True } self.inspection_data.append(inspection_point) def execute(self): \"\"\"Execute the inspection mission.\"\"\" rospy.loginfo(\"Starting autonomous inspection mission\") try: # Phase 1: Structure approach self.update_state('approaching') approach_success = self.approach_structure() if not approach_success: self.update_state('failed') return False # Phase 2: Systematic inspection self.update_state('inspecting') inspection_success = self.execute_inspection_pattern() if not inspection_success: self.update_state('failed') return False # Phase 3: Detailed defect analysis if self.defects_found: self.update_state('analyzing') analysis_success = self.analyze_defects() if not analysis_success: self.update_state('failed') return False # Phase 4: Report generation self.update_state('reporting') self.generate_inspection_report() self.update_state('completed') rospy.loginfo(\"Inspection mission completed successfully\") return True except Exception as e: rospy.logerr(f\"Inspection mission failed: {e}\") self.update_state('failed') return False def approach_structure(self): \"\"\"Approach the structure to be inspected.\"\"\" rospy.loginfo(\"Approaching inspection structure\") # Define approach waypoints approach_poses = self.generate_approach_trajectory() for pose in approach_poses: success = self.motion_client.goto_pose(pose) if not success: rospy.logwarn(\"Failed to reach approach waypoint\") return False return True def execute_inspection_pattern(self): \"\"\"Execute systematic inspection pattern.\"\"\" rospy.loginfo(\"Executing inspection pattern\") # Generate inspection trajectory inspection_trajectory = self.generate_inspection_trajectory() # Follow trajectory at inspection speed success = self.motion_client.follow_trajectory( trajectory=inspection_trajectory, speed=self.inspection_speed ) return success def generate_approach_trajectory(self): \"\"\"Generate trajectory for approaching the structure.\"\"\" # Simplified approach trajectory approach_poses = [] # Start position (10m away) start_pose = Pose() start_pose.position = Point(x=-10.0, y=0.0, z=-2.0) start_pose.orientation.w = 1.0 approach_poses.append(start_pose) # Intermediate position (5m away) mid_pose = Pose() mid_pose.position = Point(x=-5.0, y=0.0, z=-2.0) mid_pose.orientation.w = 1.0 approach_poses.append(mid_pose) # Final approach position final_pose = Pose() final_pose.position = Point(x=-self.inspection_distance, y=0.0, z=-2.0) final_pose.orientation.w = 1.0 approach_poses.append(final_pose) return approach_poses def generate_inspection_trajectory(self): \"\"\"Generate systematic inspection trajectory.\"\"\" trajectory = [] # Vertical scanning pattern x_pos = -self.inspection_distance z_start = -1.0 z_end = -4.0 y_range = [-3.0, 3.0] # Generate zigzag pattern z_positions = np.linspace(z_start, z_end, 10) for i, z in enumerate(z_positions): if i % 2 == 0: # Even rows: left to right y_positions = np.linspace(y_range[0], y_range[1], 5) else: # Odd rows: right to left y_positions = np.linspace(y_range[1], y_range[0], 5) for y in y_positions: pose = Pose() pose.position = Point(x=x_pos, y=y, z=z) pose.orientation.w = 1.0 trajectory.append(pose) return trajectory def process_defects(self, defects, header): \"\"\"Process detected defects.\"\"\" for defect in defects: defect_info = { 'timestamp': header.stamp, 'type': defect['type'], 'severity': defect['severity'], 'location': defect['location'], 'confidence': defect['confidence'], 'image_coords': defect['bbox'] } self.defects_found.append(defect_info) rospy.loginfo(f\"Defect detected: {defect['type']} (severity: {defect['severity']})\") def analyze_structure_3d(self, pointcloud): \"\"\"Analyze 3D structure from point cloud.\"\"\" # Simplified 3D analysis structure_data = { 'point_count': pointcloud.width * pointcloud.height, 'density': 'high', # Simplified 'surface_roughness': 0.05, # Mock value 'geometric_features': ['planar', 'cylindrical'] } return structure_data def analyze_defects(self): \"\"\"Perform detailed analysis of detected defects.\"\"\" rospy.loginfo(f\"Analyzing {len(self.defects_found)} detected defects\") for defect in self.defects_found: # Move closer to defect for detailed inspection detailed_pose = self.calculate_detailed_inspection_pose(defect) success = self.motion_client.goto_pose(detailed_pose) if success: # Perform detailed analysis detailed_analysis = self.perform_detailed_defect_analysis(defect) defect['detailed_analysis'] = detailed_analysis return True def calculate_detailed_inspection_pose(self, defect): \"\"\"Calculate pose for detailed defect inspection.\"\"\" # Move closer to defect location pose = Pose() pose.position = Point( x=-0.5, # Very close to structure y=defect['location']['y'], z=defect['location']['z'] ) pose.orientation.w = 1.0 return pose def perform_detailed_defect_analysis(self, defect): \"\"\"Perform detailed analysis of a specific defect.\"\"\" # Simulate detailed analysis rospy.sleep(3.0) analysis = { 'dimensions': {'length': 0.15, 'width': 0.08, 'depth': 0.02}, 'material_loss': 15.2, # percentage 'corrosion_rate': 0.5, # mm/year 'repair_urgency': 'medium', 'recommended_action': 'monitor' } return analysis def generate_inspection_report(self): \"\"\"Generate comprehensive inspection report.\"\"\" report = InspectionReport() report.header.stamp = rospy.Time.now() report.header.frame_id = 'inspection_report' # Summary statistics report.total_defects = len(self.defects_found) report.inspection_duration = (rospy.Time.now() - self.start_time).to_sec() report.area_covered = self.calculate_inspection_area() # Defect summary report.critical_defects = len([d for d in self.defects_found if d['severity'] == 'critical']) report.major_defects = len([d for d in self.defects_found if d['severity'] == 'major']) report.minor_defects = len([d for d in self.defects_found if d['severity'] == 'minor']) # Recommendations report.recommendations = self.generate_recommendations() # Publish report self.report_pub.publish(report) # Save detailed report to file self.save_detailed_report() rospy.loginfo(\"Inspection report generated and published\") def calculate_inspection_area(self): \"\"\"Calculate total area inspected.\"\"\" # Simplified area calculation return 25.0 # square meters def generate_recommendations(self): \"\"\"Generate maintenance recommendations.\"\"\" recommendations = [] critical_defects = [d for d in self.defects_found if d['severity'] == 'critical'] if critical_defects: recommendations.append(\"Immediate repair required for critical defects\") major_defects = [d for d in self.defects_found if d['severity'] == 'major'] if major_defects: recommendations.append(\"Schedule maintenance for major defects within 30 days\") if len(self.defects_found) &gt; 10: recommendations.append(\"Consider comprehensive structural assessment\") return recommendations def save_detailed_report(self): \"\"\"Save detailed inspection report to file.\"\"\" import json import os report_data = { 'mission_id': self.mission_id, 'timestamp': rospy.Time.now().to_sec(), 'defects': self.defects_found, 'inspection_data': self.inspection_data, 'summary': { 'total_defects': len(self.defects_found), 'area_covered': self.calculate_inspection_area(), 'recommendations': self.generate_recommendations() } } # Save to file filename = f\"inspection_report_{self.mission_id}_{int(rospy.Time.now().to_sec())}.json\" filepath = os.path.join('/tmp', filename) with open(filepath, 'w') as f: json.dump(report_data, f, indent=2, default=str) rospy.loginfo(f\"Detailed report saved to: {filepath}\") if __name__ == '__main__': try: mission = InspectionMission() mission.execute() except rospy.ROSInterruptException: pass . Example 7: Multi-Robot Coordination . #!/usr/bin/env python \"\"\" Multi-Robot Coordination Example Demonstrates coordinated operation of multiple ModCube vehicles for complex missions requiring teamwork. \"\"\" import rospy import numpy as np from geometry_msgs.msg import Pose, Point, Twist from modcube_msgs.msg import FleetCommand, VehicleState, FormationConfig from modcube_common.coordination import FleetManager, FormationController from modcube_common.communication import InterVehicleComm from std_msgs.msg import String import threading import time class MultiRobotCoordinator: def __init__(self, vehicle_id, fleet_size=3): rospy.init_node(f'coordinator_{vehicle_id}') self.vehicle_id = vehicle_id self.fleet_size = fleet_size self.is_leader = (vehicle_id == 0) # Fleet management self.fleet_manager = FleetManager(vehicle_id, fleet_size) self.formation_controller = FormationController() self.inter_vehicle_comm = InterVehicleComm(vehicle_id) # Vehicle state self.current_pose = Pose() self.current_velocity = Twist() self.vehicle_states = {} # States of all vehicles # Mission parameters self.formation_type = 'line' # line, triangle, diamond self.formation_spacing = 5.0 # meters self.mission_waypoints = [] self.current_waypoint_idx = 0 # Publishers and subscribers self.cmd_pub = rospy.Publisher(f'/modcube_{vehicle_id}/cmd_vel', Twist, queue_size=10) self.state_pub = rospy.Publisher('/fleet/vehicle_states', VehicleState, queue_size=10) self.fleet_cmd_sub = rospy.Subscriber('/fleet/commands', FleetCommand, self.fleet_command_callback) self.vehicle_state_sub = rospy.Subscriber('/fleet/vehicle_states', VehicleState, self.vehicle_state_callback) self.pose_sub = rospy.Subscriber(f'/modcube_{vehicle_id}/nav_state', VehicleState, self.pose_callback) # Inter-vehicle communication self.comm_sub = rospy.Subscriber('/fleet/inter_vehicle_comm', String, self.inter_vehicle_callback) self.comm_pub = rospy.Publisher('/fleet/inter_vehicle_comm', String, queue_size=10) # Control loop self.control_timer = rospy.Timer(rospy.Duration(0.1), self.control_loop) # State publishing timer self.state_timer = rospy.Timer(rospy.Duration(0.2), self.publish_state) rospy.loginfo(f\"Multi-robot coordinator initialized for vehicle {vehicle_id}\") # Leader initialization if self.is_leader: self.initialize_mission() def pose_callback(self, msg): \"\"\"Update current vehicle pose.\"\"\" self.current_pose = msg.pose self.current_velocity = msg.velocity def vehicle_state_callback(self, msg): \"\"\"Update fleet vehicle states.\"\"\" if msg.vehicle_id != self.vehicle_id: self.vehicle_states[msg.vehicle_id] = msg def fleet_command_callback(self, msg): \"\"\"Process fleet-wide commands.\"\"\" if msg.command_type == 'formation_change': self.change_formation(msg.formation_config) elif msg.command_type == 'mission_waypoints': self.update_mission_waypoints(msg.waypoints) elif msg.command_type == 'emergency_stop': self.emergency_stop() elif msg.command_type == 'formation_spacing': self.formation_spacing = msg.spacing def inter_vehicle_callback(self, msg): \"\"\"Process inter-vehicle communication.\"\"\" try: comm_data = eval(msg.data) # Simple parsing, use JSON in production if comm_data['target_id'] == self.vehicle_id or comm_data['target_id'] == 'all': self.process_inter_vehicle_message(comm_data) except Exception as e: rospy.logwarn(f\"Failed to process inter-vehicle message: {e}\") def initialize_mission(self): \"\"\"Initialize mission parameters (leader only).\"\"\" if not self.is_leader: return # Define mission waypoints self.mission_waypoints = [ Point(x=10.0, y=0.0, z=-2.0), Point(x=20.0, y=10.0, z=-2.0), Point(x=30.0, y=0.0, z=-2.0), Point(x=20.0, y=-10.0, z=-2.0), Point(x=0.0, y=0.0, z=-2.0) ] # Broadcast initial formation self.broadcast_formation_config() # Start mission after delay rospy.Timer(rospy.Duration(5.0), self.start_mission, oneshot=True) def broadcast_formation_config(self): \"\"\"Broadcast formation configuration to fleet.\"\"\" formation_config = FormationConfig() formation_config.formation_type = self.formation_type formation_config.spacing = self.formation_spacing formation_config.leader_id = self.vehicle_id fleet_cmd = FleetCommand() fleet_cmd.command_type = 'formation_change' fleet_cmd.formation_config = formation_config # Publish via inter-vehicle communication comm_msg = { 'sender_id': self.vehicle_id, 'target_id': 'all', 'message_type': 'formation_config', 'data': { 'formation_type': self.formation_type, 'spacing': self.formation_spacing, 'leader_id': self.vehicle_id } } self.comm_pub.publish(String(data=str(comm_msg))) def start_mission(self, event): \"\"\"Start the coordinated mission.\"\"\" if self.is_leader: rospy.loginfo(\"Starting coordinated mission\") # Broadcast mission start comm_msg = { 'sender_id': self.vehicle_id, 'target_id': 'all', 'message_type': 'mission_start', 'data': { 'waypoints': [(wp.x, wp.y, wp.z) for wp in self.mission_waypoints] } } self.comm_pub.publish(String(data=str(comm_msg))) def control_loop(self, event): \"\"\"Main control loop for coordinated movement.\"\"\" if not self.mission_waypoints: return # Calculate desired position based on role if self.is_leader: desired_pose = self.calculate_leader_position() else: desired_pose = self.calculate_follower_position() if desired_pose: # Generate control command cmd_vel = self.calculate_control_command(desired_pose) self.cmd_pub.publish(cmd_vel) def calculate_leader_position(self): \"\"\"Calculate leader's desired position.\"\"\" if self.current_waypoint_idx &gt;= len(self.mission_waypoints): return None target_waypoint = self.mission_waypoints[self.current_waypoint_idx] # Check if close enough to current waypoint distance = self.calculate_distance(self.current_pose.position, target_waypoint) if distance &lt; 2.0: # Within 2 meters self.current_waypoint_idx += 1 # Broadcast waypoint update if self.current_waypoint_idx &lt; len(self.mission_waypoints): comm_msg = { 'sender_id': self.vehicle_id, 'target_id': 'all', 'message_type': 'waypoint_update', 'data': { 'current_waypoint_idx': self.current_waypoint_idx } } self.comm_pub.publish(String(data=str(comm_msg))) else: rospy.loginfo(\"Mission completed\") return None return target_waypoint def calculate_follower_position(self): \"\"\"Calculate follower's desired position in formation.\"\"\" # Get leader state leader_state = self.vehicle_states.get(0) if not leader_state: return None # Calculate formation offset formation_offset = self.calculate_formation_offset() # Calculate desired position relative to leader desired_pose = Point() desired_pose.x = leader_state.pose.position.x + formation_offset[0] desired_pose.y = leader_state.pose.position.y + formation_offset[1] desired_pose.z = leader_state.pose.position.z + formation_offset[2] return desired_pose def calculate_formation_offset(self): \"\"\"Calculate formation offset based on vehicle ID and formation type.\"\"\" if self.formation_type == 'line': # Line formation: vehicles arranged in a line behind leader offset_x = -self.vehicle_id * self.formation_spacing offset_y = 0.0 offset_z = 0.0 elif self.formation_type == 'triangle': # Triangle formation if self.vehicle_id == 1: offset_x = -self.formation_spacing offset_y = -self.formation_spacing / 2 elif self.vehicle_id == 2: offset_x = -self.formation_spacing offset_y = self.formation_spacing / 2 else: offset_x = -self.vehicle_id * self.formation_spacing offset_y = 0.0 offset_z = 0.0 elif self.formation_type == 'diamond': # Diamond formation if self.vehicle_id == 1: offset_x = -self.formation_spacing offset_y = 0.0 elif self.vehicle_id == 2: offset_x = 0.0 offset_y = -self.formation_spacing elif self.vehicle_id == 3: offset_x = 0.0 offset_y = self.formation_spacing else: offset_x = -self.vehicle_id * self.formation_spacing offset_y = 0.0 offset_z = 0.0 else: # Default: line formation offset_x = -self.vehicle_id * self.formation_spacing offset_y = 0.0 offset_z = 0.0 return [offset_x, offset_y, offset_z] def calculate_control_command(self, target_position): \"\"\"Calculate control command to reach target position.\"\"\" cmd_vel = Twist() # Position error error_x = target_position.x - self.current_pose.position.x error_y = target_position.y - self.current_pose.position.y error_z = target_position.z - self.current_pose.position.z # Simple proportional control kp = 0.5 cmd_vel.linear.x = kp * error_x cmd_vel.linear.y = kp * error_y cmd_vel.linear.z = kp * error_z # Limit velocities max_vel = 1.0 cmd_vel.linear.x = max(-max_vel, min(max_vel, cmd_vel.linear.x)) cmd_vel.linear.y = max(-max_vel, min(max_vel, cmd_vel.linear.y)) cmd_vel.linear.z = max(-max_vel, min(max_vel, cmd_vel.linear.z)) return cmd_vel def calculate_distance(self, pos1, pos2): \"\"\"Calculate Euclidean distance between two positions.\"\"\" dx = pos1.x - pos2.x dy = pos1.y - pos2.y dz = pos1.z - pos2.z return np.sqrt(dx*dx + dy*dy + dz*dz) def change_formation(self, formation_config): \"\"\"Change formation configuration.\"\"\" self.formation_type = formation_config.formation_type self.formation_spacing = formation_config.spacing rospy.loginfo(f\"Formation changed to {self.formation_type} with spacing {self.formation_spacing}\") def update_mission_waypoints(self, waypoints): \"\"\"Update mission waypoints.\"\"\" self.mission_waypoints = waypoints self.current_waypoint_idx = 0 rospy.loginfo(f\"Mission waypoints updated: {len(waypoints)} waypoints\") def emergency_stop(self): \"\"\"Execute emergency stop.\"\"\" rospy.logwarn(\"Emergency stop activated\") # Stop vehicle stop_cmd = Twist() self.cmd_pub.publish(stop_cmd) # Clear mission waypoints self.mission_waypoints = [] def process_inter_vehicle_message(self, comm_data): \"\"\"Process inter-vehicle communication messages.\"\"\" message_type = comm_data['message_type'] data = comm_data['data'] if message_type == 'formation_config': self.formation_type = data['formation_type'] self.formation_spacing = data['spacing'] elif message_type == 'mission_start': waypoints = [Point(x=wp[0], y=wp[1], z=wp[2]) for wp in data['waypoints']] self.mission_waypoints = waypoints self.current_waypoint_idx = 0 elif message_type == 'waypoint_update': self.current_waypoint_idx = data['current_waypoint_idx'] elif message_type == 'obstacle_detected': self.handle_obstacle_detection(data) elif message_type == 'formation_adjustment': self.handle_formation_adjustment(data) def handle_obstacle_detection(self, obstacle_data): \"\"\"Handle obstacle detection from other vehicles.\"\"\" rospy.logwarn(f\"Obstacle detected by vehicle {obstacle_data['detector_id']}\") # Implement obstacle avoidance logic # This could involve formation adjustment or path replanning pass def handle_formation_adjustment(self, adjustment_data): \"\"\"Handle formation adjustment requests.\"\"\" # Implement dynamic formation adjustment pass def publish_state(self, event): \"\"\"Publish current vehicle state to fleet.\"\"\" state_msg = VehicleState() state_msg.vehicle_id = self.vehicle_id state_msg.pose = self.current_pose state_msg.velocity = self.current_velocity state_msg.timestamp = rospy.Time.now() self.state_pub.publish(state_msg) if __name__ == '__main__': import sys if len(sys.argv) &lt; 2: rospy.logerr(\"Usage: multi_robot_coordinator.py &lt;vehicle_id&gt;\") sys.exit(1) vehicle_id = int(sys.argv[1]) try: coordinator = MultiRobotCoordinator(vehicle_id) rospy.spin() except rospy.ROSInterruptException: pass . Example 8: Machine Learning Integration . #!/usr/bin/env python \"\"\" Machine Learning Integration Example Demonstrates integration of machine learning models for autonomous decision making and adaptive behavior. \"\"\" import rospy import numpy as np import tensorflow as tf from sensor_msgs.msg import Image, PointCloud2 from geometry_msgs.msg import Twist, Pose from modcube_msgs.msg import MLPrediction, BehaviorCommand from cv_bridge import CvBridge import cv2 from collections import deque import pickle import os class MLIntegratedController: def __init__(self): rospy.init_node('ml_controller') self.bridge = CvBridge() # Load pre-trained models self.load_models() # Data buffers self.image_buffer = deque(maxlen=10) self.sensor_buffer = deque(maxlen=50) self.action_history = deque(maxlen=100) # State variables self.current_pose = Pose() self.current_image = None self.current_pointcloud = None # ML parameters self.prediction_confidence_threshold = 0.7 self.learning_rate = 0.001 self.exploration_rate = 0.1 # Publishers and subscribers self.cmd_pub = rospy.Publisher('/modcube/cmd_vel', Twist, queue_size=10) self.prediction_pub = rospy.Publisher('/modcube/ml_prediction', MLPrediction, queue_size=10) self.image_sub = rospy.Subscriber('/modcube/camera/image_raw', Image, self.image_callback) self.pointcloud_sub = rospy.Subscriber('/modcube/pointcloud', PointCloud2, self.pointcloud_callback) self.pose_sub = rospy.Subscriber('/modcube/nav_state', Pose, self.pose_callback) # Control loop self.control_timer = rospy.Timer(rospy.Duration(0.1), self.control_loop) # Model update timer self.update_timer = rospy.Timer(rospy.Duration(1.0), self.update_models) rospy.loginfo(\"ML integrated controller initialized\") def load_models(self): \"\"\"Load pre-trained machine learning models.\"\"\" model_path = rospy.get_param('~model_path', '/tmp/modcube_models') try: # Object detection model self.object_detector = tf.keras.models.load_model( os.path.join(model_path, 'object_detector.h5') ) # Behavior prediction model self.behavior_predictor = tf.keras.models.load_model( os.path.join(model_path, 'behavior_predictor.h5') ) # Reinforcement learning policy with open(os.path.join(model_path, 'rl_policy.pkl'), 'rb') as f: self.rl_policy = pickle.load(f) rospy.loginfo(\"ML models loaded successfully\") except Exception as e: rospy.logwarn(f\"Failed to load ML models: {e}\") # Initialize simple models as fallback self.initialize_fallback_models() def initialize_fallback_models(self): \"\"\"Initialize simple fallback models.\"\"\" # Simple CNN for object detection self.object_detector = tf.keras.Sequential([ tf.keras.layers.Conv2D(32, 3, activation='relu', input_shape=(224, 224, 3)), tf.keras.layers.MaxPooling2D(), tf.keras.layers.Conv2D(64, 3, activation='relu'), tf.keras.layers.MaxPooling2D(), tf.keras.layers.Conv2D(64, 3, activation='relu'), tf.keras.layers.Flatten(), tf.keras.layers.Dense(64, activation='relu'), tf.keras.layers.Dense(10, activation='softmax') # 10 object classes ]) # Simple LSTM for behavior prediction self.behavior_predictor = tf.keras.Sequential([ tf.keras.layers.LSTM(50, input_shape=(10, 6)), # 10 timesteps, 6 features tf.keras.layers.Dense(25, activation='relu'), tf.keras.layers.Dense(3, activation='softmax') # 3 behaviors ]) # Simple Q-learning policy self.rl_policy = { 'q_table': np.random.rand(100, 4), # 100 states, 4 actions 'state_discretizer': lambda x: min(99, max(0, int(x * 10))) } rospy.loginfo(\"Fallback models initialized\") def image_callback(self, msg): \"\"\"Process incoming camera images.\"\"\" try: cv_image = self.bridge.imgmsg_to_cv2(msg, \"bgr8\") self.current_image = cv_image # Add to buffer self.image_buffer.append(cv_image) # Perform object detection self.detect_objects(cv_image) except Exception as e: rospy.logerr(f\"Image processing error: {e}\") def pointcloud_callback(self, msg): \"\"\"Process point cloud data.\"\"\" self.current_pointcloud = msg # Extract features from point cloud features = self.extract_pointcloud_features(msg) # Add to sensor buffer sensor_data = { 'timestamp': msg.header.stamp.to_sec(), 'pointcloud_features': features } self.sensor_buffer.append(sensor_data) def pose_callback(self, msg): \"\"\"Update current pose.\"\"\" self.current_pose = msg def detect_objects(self, image): \"\"\"Detect objects in the image using ML model.\"\"\" try: # Preprocess image processed_image = self.preprocess_image(image) # Run inference predictions = self.object_detector.predict(processed_image) # Process predictions detected_objects = self.process_object_predictions(predictions) # Publish predictions self.publish_ml_predictions(detected_objects) except Exception as e: rospy.logerr(f\"Object detection error: {e}\") def preprocess_image(self, image): \"\"\"Preprocess image for ML model input.\"\"\" # Resize to model input size resized = cv2.resize(image, (224, 224)) # Normalize normalized = resized.astype(np.float32) / 255.0 # Add batch dimension batched = np.expand_dims(normalized, axis=0) return batched def process_object_predictions(self, predictions): \"\"\"Process object detection predictions.\"\"\" detected_objects = [] # Get class with highest confidence class_idx = np.argmax(predictions[0]) confidence = predictions[0][class_idx] if confidence &gt; self.prediction_confidence_threshold: object_classes = ['obstacle', 'target', 'wall', 'floor', 'ceiling', 'vehicle', 'debris', 'structure', 'marker', 'unknown'] detected_objects.append({ 'class': object_classes[class_idx], 'confidence': float(confidence), 'timestamp': rospy.Time.now().to_sec() }) return detected_objects def extract_pointcloud_features(self, pointcloud): \"\"\"Extract features from point cloud data.\"\"\" # Simplified feature extraction features = { 'point_count': pointcloud.width * pointcloud.height, 'density': 1.0, # Placeholder 'mean_distance': 2.0, # Placeholder 'variance': 0.5, # Placeholder 'obstacle_detected': False # Placeholder } return features def control_loop(self, event): \"\"\"Main control loop with ML-based decision making.\"\"\" if not self.current_image or not self.sensor_buffer: return # Get current state current_state = self.get_current_state() # Predict behavior using ML predicted_behavior = self.predict_behavior(current_state) # Generate action using RL policy action = self.select_action(current_state, predicted_behavior) # Convert action to control command cmd_vel = self.action_to_command(action) # Publish command self.cmd_pub.publish(cmd_vel) # Store action for learning self.action_history.append({ 'state': current_state, 'action': action, 'timestamp': rospy.Time.now().to_sec() }) def get_current_state(self): \"\"\"Get current state representation for ML models.\"\"\" state = { 'pose': { 'x': self.current_pose.position.x, 'y': self.current_pose.position.y, 'z': self.current_pose.position.z }, 'sensor_data': list(self.sensor_buffer)[-5:], # Last 5 sensor readings 'image_available': self.current_image is not None, 'pointcloud_available': self.current_pointcloud is not None } return state def predict_behavior(self, state): \"\"\"Predict optimal behavior using ML model.\"\"\" try: # Prepare input for behavior predictor behavior_input = self.prepare_behavior_input(state) # Run prediction behavior_probs = self.behavior_predictor.predict(behavior_input) # Get predicted behavior behavior_classes = ['explore', 'approach', 'avoid'] predicted_class = np.argmax(behavior_probs[0]) confidence = behavior_probs[0][predicted_class] return { 'behavior': behavior_classes[predicted_class], 'confidence': float(confidence) } except Exception as e: rospy.logerr(f\"Behavior prediction error: {e}\") return {'behavior': 'explore', 'confidence': 0.5} def prepare_behavior_input(self, state): \"\"\"Prepare input for behavior prediction model.\"\"\" # Create feature vector from state features = [] # Add pose features features.extend([state['pose']['x'], state['pose']['y'], state['pose']['z']]) # Add sensor features (simplified) if state['sensor_data']: latest_sensor = state['sensor_data'][-1] features.extend([ latest_sensor['pointcloud_features']['point_count'] / 1000.0, latest_sensor['pointcloud_features']['density'], latest_sensor['pointcloud_features']['mean_distance'] ]) else: features.extend([0.0, 0.0, 0.0]) # Create sequence for LSTM (repeat current features for simplicity) sequence = np.array([features] * 10) # Add batch dimension batched_sequence = np.expand_dims(sequence, axis=0) return batched_sequence def select_action(self, state, predicted_behavior): \"\"\"Select action using RL policy.\"\"\" try: # Discretize state for Q-table lookup state_idx = self.discretize_state(state) # Epsilon-greedy action selection if np.random.random() &lt; self.exploration_rate: # Random action action = np.random.randint(0, 4) else: # Greedy action from Q-table q_values = self.rl_policy['q_table'][state_idx] action = np.argmax(q_values) return action except Exception as e: rospy.logerr(f\"Action selection error: {e}\") return 0 # Default action def discretize_state(self, state): \"\"\"Discretize continuous state for Q-table lookup.\"\"\" # Simple discretization based on position x_discrete = min(9, max(0, int((state['pose']['x'] + 10) / 2))) y_discrete = min(9, max(0, int((state['pose']['y'] + 10) / 2))) state_idx = x_discrete * 10 + y_discrete return min(99, state_idx) def action_to_command(self, action): \"\"\"Convert discrete action to velocity command.\"\"\" cmd_vel = Twist() # Action mapping: 0=forward, 1=backward, 2=left, 3=right if action == 0: # Forward cmd_vel.linear.x = 0.5 elif action == 1: # Backward cmd_vel.linear.x = -0.5 elif action == 2: # Left cmd_vel.linear.y = 0.5 elif action == 3: # Right cmd_vel.linear.y = -0.5 return cmd_vel def update_models(self, event): \"\"\"Periodically update ML models with new data.\"\"\" if len(self.action_history) &lt; 10: return try: # Update RL policy with recent experiences self.update_rl_policy() # Optionally retrain other models # self.retrain_behavior_predictor() except Exception as e: rospy.logerr(f\"Model update error: {e}\") def update_rl_policy(self): \"\"\"Update RL policy using recent experiences.\"\"\" # Simple Q-learning update for i in range(len(self.action_history) - 1): current_exp = self.action_history[i] next_exp = self.action_history[i + 1] # Calculate reward (simplified) reward = self.calculate_reward(current_exp, next_exp) # Q-learning update current_state_idx = self.discretize_state(current_exp['state']) next_state_idx = self.discretize_state(next_exp['state']) action = current_exp['action'] # Q(s,a) = Q(s,a) + α[r + γ*max(Q(s',a')) - Q(s,a)] alpha = self.learning_rate gamma = 0.9 current_q = self.rl_policy['q_table'][current_state_idx][action] max_next_q = np.max(self.rl_policy['q_table'][next_state_idx]) new_q = current_q + alpha * (reward + gamma * max_next_q - current_q) self.rl_policy['q_table'][current_state_idx][action] = new_q def calculate_reward(self, current_exp, next_exp): \"\"\"Calculate reward for RL update.\"\"\" # Simple reward function current_pos = current_exp['state']['pose'] next_pos = next_exp['state']['pose'] # Reward for movement (exploration) movement = np.sqrt( (next_pos['x'] - current_pos['x'])**2 + (next_pos['y'] - current_pos['y'])**2 ) reward = movement * 0.1 # Small positive reward for movement # Penalty for staying in same place if movement &lt; 0.1: reward -= 0.05 return reward def publish_ml_predictions(self, predictions): \"\"\"Publish ML predictions.\"\"\" for pred in predictions: ml_msg = MLPrediction() ml_msg.header.stamp = rospy.Time.now() ml_msg.object_class = pred['class'] ml_msg.confidence = pred['confidence'] self.prediction_pub.publish(ml_msg) if __name__ == '__main__': try: controller = MLIntegratedController() rospy.spin() except rospy.ROSInterruptException: pass . Example 9: Real-Time Optimization and Performance Monitoring . #!/usr/bin/env python \"\"\" Real-Time Optimization and Performance Monitoring Demonstrates advanced optimization techniques and comprehensive performance monitoring for ModCube systems. \"\"\" import rospy import numpy as np import time from geometry_msgs.msg import Twist, Pose from sensor_msgs.msg import Imu, FluidPressure from modcube_msgs.msg import PerformanceMetrics, OptimizationStatus from std_msgs.msg import Float64MultiArray import threading from collections import deque import psutil import resource from scipy.optimize import minimize import cvxpy as cp class RealTimeOptimizer: def __init__(self): rospy.init_node('realtime_optimizer') # Performance monitoring self.cpu_usage_history = deque(maxlen=100) self.memory_usage_history = deque(maxlen=100) self.control_loop_times = deque(maxlen=1000) self.optimization_times = deque(maxlen=100) # System state self.current_pose = Pose() self.current_velocity = Twist() self.imu_data = None self.pressure_data = None # Optimization parameters self.optimization_horizon = 10 # MPC horizon self.dt = 0.1 # Time step self.max_optimization_time = 0.05 # 50ms max # Control constraints self.max_thrust = 50.0 # N self.max_velocity = 2.0 # m/s self.max_acceleration = 1.0 # m/s² # Performance thresholds self.cpu_threshold = 80.0 # % self.memory_threshold = 85.0 # % self.control_frequency_threshold = 8.0 # Hz minimum # Adaptive parameters self.adaptive_horizon = True self.dynamic_constraints = True self.load_balancing = True # Publishers and subscribers self.cmd_pub = rospy.Publisher('/modcube/cmd_vel', Twist, queue_size=1) self.metrics_pub = rospy.Publisher('/modcube/performance_metrics', PerformanceMetrics, queue_size=10) self.optimization_pub = rospy.Publisher('/modcube/optimization_status', OptimizationStatus, queue_size=10) self.pose_sub = rospy.Subscriber('/modcube/nav_state', Pose, self.pose_callback) self.imu_sub = rospy.Subscriber('/modcube/imu', Imu, self.imu_callback) self.pressure_sub = rospy.Subscriber('/modcube/pressure', FluidPressure, self.pressure_callback) # Target waypoints self.target_waypoints = [ [10.0, 0.0, -2.0], [20.0, 10.0, -3.0], [30.0, 0.0, -2.0], [20.0, -10.0, -4.0], [0.0, 0.0, -2.0] ] self.current_target_idx = 0 # Control and monitoring timers self.control_timer = rospy.Timer(rospy.Duration(self.dt), self.control_loop) self.monitoring_timer = rospy.Timer(rospy.Duration(1.0), self.monitor_performance) self.optimization_timer = rospy.Timer(rospy.Duration(0.5), self.adaptive_optimization) rospy.loginfo(\"Real-time optimizer initialized\") def pose_callback(self, msg): \"\"\"Update current pose.\"\"\" self.current_pose = msg def imu_callback(self, msg): \"\"\"Update IMU data.\"\"\" self.imu_data = msg def pressure_callback(self, msg): \"\"\"Update pressure data.\"\"\" self.pressure_data = msg def control_loop(self, event): \"\"\"Main control loop with real-time optimization.\"\"\" start_time = time.time() try: # Get current state current_state = self.get_current_state() if current_state is None: return # Get current target target = self.get_current_target() if target is None: return # Solve optimization problem optimal_control = self.solve_mpc_problem(current_state, target) # Apply control if optimal_control is not None: cmd_vel = self.control_to_twist(optimal_control) self.cmd_pub.publish(cmd_vel) # Record timing loop_time = time.time() - start_time self.control_loop_times.append(loop_time) # Check for target reached self.check_target_reached(current_state, target) except Exception as e: rospy.logerr(f\"Control loop error: {e}\") def get_current_state(self): \"\"\"Get current system state.\"\"\" if not self.current_pose: return None state = np.array([ self.current_pose.position.x, self.current_pose.position.y, self.current_pose.position.z, 0.0, # vx (would come from velocity estimation) 0.0, # vy 0.0 # vz ]) return state def get_current_target(self): \"\"\"Get current target waypoint.\"\"\" if self.current_target_idx &gt;= len(self.target_waypoints): return None return np.array(self.target_waypoints[self.current_target_idx]) def solve_mpc_problem(self, current_state, target): \"\"\"Solve Model Predictive Control optimization problem.\"\"\" start_time = time.time() try: # Adaptive horizon based on system load horizon = self.get_adaptive_horizon() # State and control dimensions n_states = 6 # [x, y, z, vx, vy, vz] n_controls = 3 # [fx, fy, fz] # Decision variables x = cp.Variable((n_states, horizon + 1)) u = cp.Variable((n_controls, horizon)) # System dynamics (simplified) A = np.eye(n_states) A[0:3, 3:6] = np.eye(3) * self.dt # position integration B = np.zeros((n_states, n_controls)) B[3:6, 0:3] = np.eye(3) * self.dt # acceleration from thrust # Cost matrices Q = np.diag([10, 10, 10, 1, 1, 1]) # State cost R = np.diag([0.1, 0.1, 0.1]) # Control cost Qf = Q * 10 # Terminal cost # Objective function cost = 0 constraints = [] # Initial condition constraints.append(x[:, 0] == current_state) for k in range(horizon): # Dynamics constraint constraints.append(x[:, k+1] == A @ x[:, k] + B @ u[:, k]) # Stage cost target_state = np.concatenate([target, np.zeros(3)]) cost += cp.quad_form(x[:, k] - target_state, Q) cost += cp.quad_form(u[:, k], R) # Control constraints constraints.append(cp.norm(u[:, k], 2) &lt;= self.max_thrust) # Velocity constraints constraints.append(cp.norm(x[3:6, k], 2) &lt;= self.max_velocity) # Terminal cost target_state = np.concatenate([target, np.zeros(3)]) cost += cp.quad_form(x[:, horizon] - target_state, Qf) # Solve optimization problem problem = cp.Problem(cp.Minimize(cost), constraints) # Set solver parameters for real-time performance problem.solve(solver=cp.OSQP, max_iter=1000, eps_abs=1e-3, eps_rel=1e-3, verbose=False) optimization_time = time.time() - start_time self.optimization_times.append(optimization_time) # Publish optimization status self.publish_optimization_status(problem.status, optimization_time) if problem.status == cp.OPTIMAL: return u.value[:, 0] # Return first control action else: rospy.logwarn(f\"Optimization failed with status: {problem.status}\") return None except Exception as e: rospy.logerr(f\"MPC optimization error: {e}\") return None def get_adaptive_horizon(self): \"\"\"Get adaptive optimization horizon based on system load.\"\"\" if not self.adaptive_horizon: return self.optimization_horizon # Get current CPU usage current_cpu = psutil.cpu_percent() # Reduce horizon if CPU usage is high if current_cpu &gt; self.cpu_threshold: return max(3, self.optimization_horizon // 2) elif current_cpu &gt; 60: return max(5, int(self.optimization_horizon * 0.75)) else: return self.optimization_horizon def control_to_twist(self, control): \"\"\"Convert control forces to Twist message.\"\"\" cmd_vel = Twist() # Simple mapping from forces to velocities # In practice, this would involve thruster allocation cmd_vel.linear.x = np.clip(control[0] / 10.0, -2.0, 2.0) cmd_vel.linear.y = np.clip(control[1] / 10.0, -2.0, 2.0) cmd_vel.linear.z = np.clip(control[2] / 10.0, -2.0, 2.0) return cmd_vel def check_target_reached(self, current_state, target): \"\"\"Check if current target is reached.\"\"\" distance = np.linalg.norm(current_state[0:3] - target) if distance &lt; 1.0: # Within 1 meter self.current_target_idx += 1 if self.current_target_idx &lt; len(self.target_waypoints): rospy.loginfo(f\"Target {self.current_target_idx - 1} reached. Moving to next target.\") else: rospy.loginfo(\"All targets reached. Mission complete.\") def monitor_performance(self, event): \"\"\"Monitor system performance metrics.\"\"\" try: # CPU and memory usage cpu_percent = psutil.cpu_percent() memory_info = psutil.virtual_memory() memory_percent = memory_info.percent self.cpu_usage_history.append(cpu_percent) self.memory_usage_history.append(memory_percent) # Control loop frequency if len(self.control_loop_times) &gt; 10: recent_times = list(self.control_loop_times)[-10:] avg_loop_time = np.mean(recent_times) control_frequency = 1.0 / avg_loop_time if avg_loop_time &gt; 0 else 0 else: control_frequency = 0 # Optimization performance if len(self.optimization_times) &gt; 5: recent_opt_times = list(self.optimization_times)[-5:] avg_opt_time = np.mean(recent_opt_times) max_opt_time = np.max(recent_opt_times) else: avg_opt_time = 0 max_opt_time = 0 # Publish performance metrics self.publish_performance_metrics( cpu_percent, memory_percent, control_frequency, avg_opt_time, max_opt_time ) # Check for performance issues self.check_performance_issues( cpu_percent, memory_percent, control_frequency ) except Exception as e: rospy.logerr(f\"Performance monitoring error: {e}\") def publish_performance_metrics(self, cpu_percent, memory_percent, control_frequency, avg_opt_time, max_opt_time): \"\"\"Publish performance metrics.\"\"\" metrics = PerformanceMetrics() metrics.header.stamp = rospy.Time.now() metrics.cpu_usage = cpu_percent metrics.memory_usage = memory_percent metrics.control_frequency = control_frequency metrics.avg_optimization_time = avg_opt_time metrics.max_optimization_time = max_opt_time # Calculate additional metrics if len(self.cpu_usage_history) &gt; 1: metrics.cpu_usage_trend = np.mean(list(self.cpu_usage_history)[-10:]) if len(self.control_loop_times) &gt; 1: metrics.control_jitter = np.std(list(self.control_loop_times)[-20:]) self.metrics_pub.publish(metrics) def publish_optimization_status(self, status, optimization_time): \"\"\"Publish optimization status.\"\"\" opt_status = OptimizationStatus() opt_status.header.stamp = rospy.Time.now() opt_status.solver_status = str(status) opt_status.solve_time = optimization_time opt_status.horizon_length = self.get_adaptive_horizon() opt_status.target_index = self.current_target_idx self.optimization_pub.publish(opt_status) def check_performance_issues(self, cpu_percent, memory_percent, control_frequency): \"\"\"Check for performance issues and take corrective actions.\"\"\" issues = [] # CPU usage check if cpu_percent &gt; self.cpu_threshold: issues.append(f\"High CPU usage: {cpu_percent:.1f}%\") if self.adaptive_horizon: rospy.logwarn(\"Reducing optimization horizon due to high CPU usage\") # Memory usage check if memory_percent &gt; self.memory_threshold: issues.append(f\"High memory usage: {memory_percent:.1f}%\") self.cleanup_old_data() # Control frequency check if control_frequency &lt; self.control_frequency_threshold: issues.append(f\"Low control frequency: {control_frequency:.1f} Hz\") # Optimization time check if len(self.optimization_times) &gt; 0: recent_opt_time = self.optimization_times[-1] if recent_opt_time &gt; self.max_optimization_time: issues.append(f\"Slow optimization: {recent_opt_time:.3f}s\") if issues: rospy.logwarn(f\"Performance issues detected: {', '.join(issues)}\") def cleanup_old_data(self): \"\"\"Clean up old data to free memory.\"\"\" # Reduce buffer sizes temporarily if len(self.control_loop_times) &gt; 500: # Keep only recent data recent_data = list(self.control_loop_times)[-500:] self.control_loop_times.clear() self.control_loop_times.extend(recent_data) rospy.loginfo(\"Cleaned up old performance data\") def adaptive_optimization(self, event): \"\"\"Perform adaptive optimization parameter tuning.\"\"\" try: # Analyze recent performance if len(self.optimization_times) &lt; 5: return recent_opt_times = list(self.optimization_times)[-5:] avg_opt_time = np.mean(recent_opt_times) # Adjust parameters based on performance if avg_opt_time &gt; self.max_optimization_time * 0.8: # Optimization is taking too long if self.optimization_horizon &gt; 3: self.optimization_horizon -= 1 rospy.loginfo(f\"Reduced optimization horizon to {self.optimization_horizon}\") elif avg_opt_time &lt; self.max_optimization_time * 0.3: # Optimization is fast, can increase horizon if self.optimization_horizon &lt; 15: self.optimization_horizon += 1 rospy.loginfo(f\"Increased optimization horizon to {self.optimization_horizon}\") # Adjust control frequency based on system load current_cpu = psutil.cpu_percent() if current_cpu &gt; self.cpu_threshold and self.dt &lt; 0.2: self.dt += 0.01 # Update timer self.control_timer.shutdown() self.control_timer = rospy.Timer(rospy.Duration(self.dt), self.control_loop) rospy.loginfo(f\"Reduced control frequency to {1.0/self.dt:.1f} Hz\") elif current_cpu &lt; 50 and self.dt &gt; 0.05: self.dt -= 0.01 # Update timer self.control_timer.shutdown() self.control_timer = rospy.Timer(rospy.Duration(self.dt), self.control_loop) rospy.loginfo(f\"Increased control frequency to {1.0/self.dt:.1f} Hz\") except Exception as e: rospy.logerr(f\"Adaptive optimization error: {e}\") class PerformanceBenchmark: \"\"\"Performance benchmarking utilities.\"\"\" def __init__(self): self.benchmark_results = {} def benchmark_control_loop(self, optimizer, iterations=1000): \"\"\"Benchmark control loop performance.\"\"\" rospy.loginfo(f\"Starting control loop benchmark ({iterations} iterations)\") times = [] for i in range(iterations): start_time = time.time() # Simulate control loop current_state = np.random.rand(6) target = np.random.rand(3) * 10 optimal_control = optimizer.solve_mpc_problem(current_state, target) end_time = time.time() times.append(end_time - start_time) if i % 100 == 0: rospy.loginfo(f\"Benchmark progress: {i}/{iterations}\") # Calculate statistics avg_time = np.mean(times) std_time = np.std(times) max_time = np.max(times) min_time = np.min(times) self.benchmark_results['control_loop'] = { 'avg_time': avg_time, 'std_time': std_time, 'max_time': max_time, 'min_time': min_time, 'frequency': 1.0 / avg_time } rospy.loginfo(f\"Control loop benchmark results:\") rospy.loginfo(f\" Average time: {avg_time:.4f}s\") rospy.loginfo(f\" Std deviation: {std_time:.4f}s\") rospy.loginfo(f\" Max time: {max_time:.4f}s\") rospy.loginfo(f\" Min time: {min_time:.4f}s\") rospy.loginfo(f\" Average frequency: {1.0/avg_time:.1f} Hz\") def benchmark_memory_usage(self, duration=60): \"\"\"Benchmark memory usage over time.\"\"\" rospy.loginfo(f\"Starting memory benchmark ({duration}s)\") start_time = time.time() memory_samples = [] while time.time() - start_time &lt; duration: memory_info = psutil.virtual_memory() memory_samples.append(memory_info.percent) time.sleep(1.0) # Calculate statistics avg_memory = np.mean(memory_samples) max_memory = np.max(memory_samples) min_memory = np.min(memory_samples) self.benchmark_results['memory'] = { 'avg_usage': avg_memory, 'max_usage': max_memory, 'min_usage': min_memory, 'samples': len(memory_samples) } rospy.loginfo(f\"Memory benchmark results:\") rospy.loginfo(f\" Average usage: {avg_memory:.1f}%\") rospy.loginfo(f\" Max usage: {max_memory:.1f}%\") rospy.loginfo(f\" Min usage: {min_memory:.1f}%\") if __name__ == '__main__': try: optimizer = RealTimeOptimizer() # Optional: Run benchmarks if rospy.get_param('~run_benchmark', False): benchmark = PerformanceBenchmark() benchmark.benchmark_control_loop(optimizer, 100) benchmark.benchmark_memory_usage(30) rospy.spin() except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#mission-planning",
    
    "relUrl": "/examples/#mission-planning"
  },"63": {
    "doc": "Examples",
    "title": "Advanced Integration Examples",
    "content": "Example 10: Complete Mission Integration . #!/usr/bin/env python \"\"\" Complete Mission Integration Example Demonstrates integration of all advanced features: - Multi-robot coordination - Machine learning - Real-time optimization - Performance monitoring \"\"\" import rospy from multi_robot_coordinator import MultiRobotCoordinator from ml_integrated_controller import MLIntegratedController from realtime_optimizer import RealTimeOptimizer import threading import time class IntegratedMissionController: def __init__(self, vehicle_id): self.vehicle_id = vehicle_id # Initialize subsystems self.coordinator = MultiRobotCoordinator(vehicle_id) self.ml_controller = MLIntegratedController() self.optimizer = RealTimeOptimizer() # Mission state self.mission_active = False self.mission_phase = 'idle' rospy.loginfo(f\"Integrated mission controller initialized for vehicle {vehicle_id}\") def execute_integrated_mission(self): \"\"\"Execute complete integrated mission.\"\"\" rospy.loginfo(\"Starting integrated mission\") try: # Phase 1: Formation and coordination self.mission_phase = 'formation' self.execute_formation_phase() # Phase 2: ML-guided exploration self.mission_phase = 'exploration' self.execute_exploration_phase() # Phase 3: Optimized task execution self.mission_phase = 'execution' self.execute_task_phase() # Phase 4: Return and debrief self.mission_phase = 'return' self.execute_return_phase() rospy.loginfo(\"Integrated mission completed successfully\") except Exception as e: rospy.logerr(f\"Integrated mission failed: {e}\") def execute_formation_phase(self): \"\"\"Execute formation and coordination phase.\"\"\" rospy.loginfo(\"Executing formation phase\") # Formation logic handled by coordinator time.sleep(10) # Simulate formation time def execute_exploration_phase(self): \"\"\"Execute ML-guided exploration phase.\"\"\" rospy.loginfo(\"Executing exploration phase\") # ML exploration logic time.sleep(20) # Simulate exploration time def execute_task_phase(self): \"\"\"Execute optimized task execution phase.\"\"\" rospy.loginfo(\"Executing task phase\") # Optimized task execution time.sleep(30) # Simulate task time def execute_return_phase(self): \"\"\"Execute return phase.\"\"\" rospy.loginfo(\"Executing return phase\") # Return to base time.sleep(15) # Simulate return time if __name__ == '__main__': import sys if len(sys.argv) &lt; 2: rospy.logerr(\"Usage: integrated_mission.py &lt;vehicle_id&gt;\") sys.exit(1) vehicle_id = int(sys.argv[1]) try: controller = IntegratedMissionController(vehicle_id) # Start mission in separate thread mission_thread = threading.Thread(target=controller.execute_integrated_mission) mission_thread.start() rospy.spin() except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#advanced-integration-examples",
    
    "relUrl": "/examples/#advanced-integration-examples"
  },"64": {
    "doc": "Examples",
    "title": "Summary",
    "content": "These advanced examples demonstrate the full capabilities of the RS-ModCubes system: . | Search and Rescue Mission: Complete autonomous mission with multiple phases | Autonomous Inspection: Detailed structural inspection with computer vision | Multi-Robot Coordination: Fleet operations with formation control | Machine Learning Integration: Adaptive behavior with neural networks | Real-Time Optimization: MPC with performance monitoring | Integrated Mission: Complete system integration | . Each example showcases different aspects of advanced autonomous underwater vehicle operations, from basic control to sophisticated AI-driven decision making and multi-vehicle coordination. Key Features Demonstrated: . | Modular Architecture: Each component can be used independently | Real-Time Performance: Optimized for real-time operation | Scalability: Supports single and multi-vehicle operations | Adaptability: Machine learning and adaptive algorithms | Robustness: Error handling and performance monitoring | Integration: Seamless integration of multiple subsystems | . These examples provide a comprehensive foundation for developing advanced autonomous underwater vehicle applications using the RS-ModCubes platform. area=self.search_area, pattern=self.search_pattern, spacing=self.search_spacing ) . rospy.loginfo(f\"Generated {len(search_waypoints)} search waypoints\") # Execute search pattern for i, waypoint in enumerate(search_waypoints): if rospy.is_shutdown() or self.is_aborted(): return False rospy.loginfo(f\"Moving to search waypoint {i+1}/{len(search_waypoints)}\") success = self.motion_client.goto_position( waypoint.x, waypoint.y, waypoint.z, timeout=30.0 ) if not success: rospy.logwarn(f\"Failed to reach waypoint {i+1}\") continue # Pause for detection rospy.sleep(2.0) # Update progress progress = (i + 1) / len(search_waypoints) * 100 self.update_progress(progress) rospy.loginfo(\"Search phase completed\") return True def execute_investigation_phase(self): \"\"\"Investigate detected targets more closely.\"\"\" rospy.loginfo(f\"Starting investigation of {len(self.targets_found)} targets\") for i, target in enumerate(self.targets_found): if rospy.is_shutdown() or self.is_aborted(): return False rospy.loginfo(f\"Investigating target {target['id']}\") # Move closer to target for detailed inspection investigation_pos = Point( x=target['position'].x, y=target['position'].y, z=target['position'].z + 1.0 # 1m above target ) success = self.motion_client.goto_position( investigation_pos.x, investigation_pos.y, investigation_pos.z, timeout=20.0 ) if success: # Perform detailed inspection self.perform_detailed_inspection(target) else: rospy.logwarn(f\"Failed to reach investigation position for target {target['id']}\") # Update progress progress = (i + 1) / len(self.targets_found) * 100 self.update_progress(progress) rospy.loginfo(\"Investigation phase completed\") return True def perform_detailed_inspection(self, target): \"\"\"Perform detailed inspection of a target.\"\"\" rospy.loginfo(f\"Performing detailed inspection of target {target['id']}\") # Circle around target for multiple viewing angles circle_radius = 2.0 num_positions = 8 for i in range(num_positions): angle = 2 * np.pi * i / num_positions inspect_pos = Point( x=target['position'].x + circle_radius * np.cos(angle), y=target['position'].y + circle_radius * np.sin(angle), z=target['position'].z + 1.0 ) self.motion_client.goto_position( inspect_pos.x, inspect_pos.y, inspect_pos.z, timeout=15.0 ) # Pause for data collection rospy.sleep(1.0) # Update target information target['inspected'] = True target['inspection_time'] = rospy.Time.now() def execute_recovery_phase(self): \"\"\"Execute recovery operations for confirmed targets.\"\"\" rospy.loginfo(\"Starting recovery phase\") # Sort targets by priority (e.g., confidence, detection time) sorted_targets = sorted(self.targets_found, key=lambda t: t['confidence'], reverse=True) for i, target in enumerate(sorted_targets): if rospy.is_shutdown() or self.is_aborted(): return False rospy.loginfo(f\"Recovering target {target['id']}\") # Move to recovery position recovery_pos = Point( x=target['position'].x, y=target['position'].y, z=target['position'].z + 0.5 # 0.5m above target ) success = self.motion_client.goto_position( recovery_pos.x, recovery_pos.y, recovery_pos.z, timeout=20.0 ) if success: # Simulate recovery operation self.perform_recovery_operation(target) else: rospy.logwarn(f\"Failed to reach recovery position for target {target['id']}\") # Update progress progress = (i + 1) / len(sorted_targets) * 100 self.update_progress(progress) rospy.loginfo(\"Recovery phase completed\") return True def perform_recovery_operation(self, target): \"\"\"Perform recovery operation for a target.\"\"\" rospy.loginfo(f\"Performing recovery operation for target {target['id']}\") # Simulate manipulator operations # In practice, this would involve: # - Precise positioning # - Manipulator control # - Grasping operations # - Secure storage rospy.sleep(5.0) # Simulate recovery time target['recovered'] = True target['recovery_time'] = rospy.Time.now() rospy.loginfo(f\"Target {target['id']} successfully recovered\") . if name == ‘main’: try: rospy.init_node(‘search_rescue_mission’) . mission = SearchRescueMission() success = mission.execute() if success: rospy.loginfo(\"Search and Rescue mission completed successfully\") else: rospy.logwarn(\"Search and Rescue mission failed\") except rospy.ROSInterruptException: pass ``` . Example 6: Inspection Mission . #!/usr/bin/env python \"\"\" Infrastructure Inspection Mission Performs detailed inspection of underwater infrastructure using multiple sensors and systematic coverage patterns. \"\"\" import rospy import numpy as np from geometry_msgs.msg import Point, Pose, Quaternion from sensor_msgs.msg import Image, PointCloud2 from modcube_msgs.msg import InspectionData from modcube_mission import BaseMission from modcube_common.motion import MotionClient from modcube_common.vision import InspectionAnalyzer class InspectionMission(BaseMission): def __init__(self, structure_model): super().__init__() self.motion_client = MotionClient() self.inspection_analyzer = InspectionAnalyzer() # Structure to inspect self.structure_model = structure_model self.inspection_points = [] self.inspection_data = [] # Inspection parameters self.inspection_distance = 2.0 # meters from structure self.overlap_percentage = 30 # percent overlap between views self.inspection_speed = 0.2 # m/s # Data collection self.image_sub = rospy.Subscriber('/modcube/camera/image_raw', Image, self.image_callback) self.cloud_sub = rospy.Subscriber('/modcube/pointcloud', PointCloud2, self.cloud_callback) # Data storage self.inspection_pub = rospy.Publisher('/modcube/inspection_data', InspectionData, queue_size=10) rospy.loginfo(\"Inspection mission initialized\") def image_callback(self, msg): \"\"\"Process camera images for inspection.\"\"\" if self.get_state() == 'inspecting': # Analyze image for defects, corrosion, etc. analysis_result = self.inspection_analyzer.analyze_image(msg) if analysis_result: self.store_inspection_data('visual', analysis_result) def cloud_callback(self, msg): \"\"\"Process point cloud data for 3D inspection.\"\"\" if self.get_state() == 'inspecting': # Analyze point cloud for structural deformation analysis_result = self.inspection_analyzer.analyze_pointcloud(msg) if analysis_result: self.store_inspection_data('geometric', analysis_result) def store_inspection_data(self, data_type, analysis_result): \"\"\"Store inspection data with metadata.\"\"\" inspection_data = { 'timestamp': rospy.Time.now(), 'position': self.motion_client.get_current_pose(), 'data_type': data_type, 'analysis': analysis_result } self.inspection_data.append(inspection_data) # Publish for real-time monitoring msg = InspectionData() msg.header.stamp = inspection_data['timestamp'] msg.data_type = data_type msg.position = inspection_data['position'] # ... fill additional fields self.inspection_pub.publish(msg) def execute(self): \"\"\"Execute the inspection mission.\"\"\" rospy.loginfo(\"Starting infrastructure inspection mission\") try: # Phase 1: Generate inspection plan self.update_state('planning') planning_success = self.generate_inspection_plan() if not planning_success: self.update_state('failed') return False # Phase 2: Execute inspection self.update_state('inspecting') inspection_success = self.execute_inspection() if not inspection_success: self.update_state('failed') return False # Phase 3: Data analysis and reporting self.update_state('analyzing') analysis_success = self.analyze_inspection_data() if not analysis_success: self.update_state('failed') return False # Mission completed self.update_state('completed') rospy.loginfo(\"Inspection mission completed successfully\") return True except Exception as e: rospy.logerr(f\"Inspection mission failed: {e}\") self.update_state('failed') return False def generate_inspection_plan(self): \"\"\"Generate systematic inspection plan for the structure.\"\"\" rospy.loginfo(\"Generating inspection plan\") # For a cylindrical structure (e.g., pipeline, pillar) if self.structure_model['type'] == 'cylinder': self.inspection_points = self.generate_cylinder_inspection_points() # For a planar structure (e.g., wall, panel) elif self.structure_model['type'] == 'plane': self.inspection_points = self.generate_plane_inspection_points() # For a complex structure elif self.structure_model['type'] == 'complex': self.inspection_points = self.generate_complex_inspection_points() else: rospy.logerr(f\"Unknown structure type: {self.structure_model['type']}\") return False rospy.loginfo(f\"Generated {len(self.inspection_points)} inspection points\") return True def generate_cylinder_inspection_points(self): \"\"\"Generate inspection points for cylindrical structure.\"\"\" points = [] center = self.structure_model['center'] radius = self.structure_model['radius'] height = self.structure_model['height'] # Calculate inspection parameters inspection_radius = radius + self.inspection_distance # Vertical spacing based on camera field of view vertical_spacing = 1.0 # meters num_levels = int(height / vertical_spacing) + 1 # Angular spacing for complete coverage angular_spacing = np.pi / 6 # 30 degrees num_angles = int(2 * np.pi / angular_spacing) for level in range(num_levels): z = center[2] - height/2 + level * vertical_spacing for angle_idx in range(num_angles): angle = angle_idx * angular_spacing x = center[0] + inspection_radius * np.cos(angle) y = center[1] + inspection_radius * np.sin(angle) # Calculate orientation to face the structure yaw = angle + np.pi # Face inward point = { 'position': Point(x, y, z), 'orientation': self.yaw_to_quaternion(yaw), 'level': level, 'angle': angle } points.append(point) return points def generate_plane_inspection_points(self): \"\"\"Generate inspection points for planar structure.\"\"\" points = [] # Structure parameters corner1 = self.structure_model['corner1'] corner2 = self.structure_model['corner2'] normal = self.structure_model['normal'] # Calculate inspection grid width = np.linalg.norm(np.array(corner2) - np.array(corner1)) height = self.structure_model['height'] grid_spacing = 1.5 # meters num_x = int(width / grid_spacing) + 1 num_z = int(height / grid_spacing) + 1 for i in range(num_x): for j in range(num_z): # Calculate position on the structure surface u = i / (num_x - 1) if num_x &gt; 1 else 0 v = j / (num_z - 1) if num_z &gt; 1 else 0 surface_point = ( np.array(corner1) * (1 - u) + np.array(corner2) * u + np.array([0, 0, v * height]) ) # Offset by inspection distance along normal inspection_point = surface_point + np.array(normal) * self.inspection_distance # Calculate orientation to face the structure orientation = self.normal_to_quaternion(normal) point = { 'position': Point(inspection_point[0], inspection_point[1], inspection_point[2]), 'orientation': orientation, 'grid_x': i, 'grid_z': j } points.append(point) return points def execute_inspection(self): \"\"\"Execute the inspection by visiting all planned points.\"\"\" rospy.loginfo(\"Starting inspection execution\") for i, point in enumerate(self.inspection_points): if rospy.is_shutdown() or self.is_aborted(): return False rospy.loginfo(f\"Moving to inspection point {i+1}/{len(self.inspection_points)}\") # Create pose from point pose = Pose() pose.position = point['position'] pose.orientation = point['orientation'] # Move to inspection point success = self.motion_client.goto_pose(pose, timeout=30.0) if not success: rospy.logwarn(f\"Failed to reach inspection point {i+1}\") continue # Perform inspection at this point self.perform_point_inspection(point) # Update progress progress = (i + 1) / len(self.inspection_points) * 100 self.update_progress(progress) rospy.loginfo(\"Inspection execution completed\") return True def perform_point_inspection(self, point): \"\"\"Perform detailed inspection at a specific point.\"\"\" # Stabilize at position rospy.sleep(1.0) # Collect data for specified duration inspection_duration = 3.0 # seconds start_time = rospy.Time.now() while (rospy.Time.now() - start_time).to_sec() &lt; inspection_duration: rospy.sleep(0.1) rospy.loginfo(f\"Completed inspection at point {point['position']}\") def analyze_inspection_data(self): \"\"\"Analyze collected inspection data and generate report.\"\"\" rospy.loginfo(\"Analyzing inspection data\") # Categorize findings defects = [] anomalies = [] measurements = [] for data in self.inspection_data: analysis = data['analysis'] if 'defects' in analysis: defects.extend(analysis['defects']) if 'anomalies' in analysis: anomalies.extend(analysis['anomalies']) if 'measurements' in analysis: measurements.extend(analysis['measurements']) # Generate summary report report = { 'total_points_inspected': len(self.inspection_points), 'total_data_collected': len(self.inspection_data), 'defects_found': len(defects), 'anomalies_detected': len(anomalies), 'measurements_taken': len(measurements), 'inspection_coverage': self.calculate_coverage(), 'recommendations': self.generate_recommendations(defects, anomalies) } # Save report self.save_inspection_report(report) rospy.loginfo(f\"Analysis completed. Found {len(defects)} defects and {len(anomalies)} anomalies\") return True def calculate_coverage(self): \"\"\"Calculate inspection coverage percentage.\"\"\" # Simplified coverage calculation # In practice, this would be more sophisticated planned_points = len(self.inspection_points) completed_points = len([d for d in self.inspection_data if d['data_type'] == 'visual']) return (completed_points / planned_points) * 100 if planned_points &gt; 0 else 0 def generate_recommendations(self, defects, anomalies): \"\"\"Generate maintenance recommendations based on findings.\"\"\" recommendations = [] if len(defects) &gt; 5: recommendations.append(\"High number of defects detected. Immediate maintenance recommended.\") if len(anomalies) &gt; 0: recommendations.append(\"Structural anomalies detected. Further investigation required.\") if len(defects) == 0 and len(anomalies) == 0: recommendations.append(\"Structure appears to be in good condition. Continue regular monitoring.\") return recommendations def save_inspection_report(self, report): \"\"\"Save inspection report to file.\"\"\" import json import os timestamp = rospy.Time.now().to_sec() filename = f\"inspection_report_{timestamp}.json\" filepath = os.path.join(\"/tmp\", filename) with open(filepath, 'w') as f: json.dump(report, f, indent=2, default=str) rospy.loginfo(f\"Inspection report saved to {filepath}\") def yaw_to_quaternion(self, yaw): \"\"\"Convert yaw angle to quaternion.\"\"\" import math return Quaternion( x=0.0, y=0.0, z=math.sin(yaw / 2.0), w=math.cos(yaw / 2.0) ) def normal_to_quaternion(self, normal): \"\"\"Convert normal vector to quaternion orientation.\"\"\" import math # Calculate yaw and pitch from normal vector yaw = math.atan2(normal[1], normal[0]) pitch = math.asin(-normal[2]) # Convert to quaternion cy = math.cos(yaw * 0.5) sy = math.sin(yaw * 0.5) cp = math.cos(pitch * 0.5) sp = math.sin(pitch * 0.5) return Quaternion( x=sp * cy, y=0.0, z=sy * cp, w=cp * cy ) if __name__ == '__main__': try: rospy.init_node('inspection_mission') # Define structure to inspect structure_model = { 'type': 'cylinder', 'center': [10, 10, -5], 'radius': 2.0, 'height': 10.0 } mission = InspectionMission(structure_model) success = mission.execute() if success: rospy.loginfo(\"Inspection mission completed successfully\") else: rospy.logwarn(\"Inspection mission failed\") except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#summary",
    
    "relUrl": "/examples/#summary"
  },"65": {
    "doc": "Examples",
    "title": "Sensor Integration",
    "content": "Example 7: Multi-Sensor Fusion . #!/usr/bin/env python \"\"\" Multi-Sensor Fusion Example Demonstrates integration and fusion of multiple sensor modalities for robust state estimation and environmental perception. \"\"\" import rospy import numpy as np from sensor_msgs.msg import Imu, Image, PointCloud2 from geometry_msgs.msg import PoseWithCovariance, TwistWithCovariance from modcube_msgs.msg import DVLData, FluidDepth, NavState from modcube_common.filters import ExtendedKalmanFilter from modcube_common.vision import VisualOdometry class MultiSensorFusion: def __init__(self): rospy.init_node('multi_sensor_fusion') # Initialize filters and processors self.ekf = ExtendedKalmanFilter(state_dim=15) # [pos, vel, acc, orient, ang_vel] self.visual_odometry = VisualOdometry() # Sensor data buffers self.imu_data = None self.dvl_data = None self.depth_data = None self.visual_data = None # Sensor subscribers self.imu_sub = rospy.Subscriber('/modcube/imu/data', Imu, self.imu_callback) self.dvl_sub = rospy.Subscriber('/modcube/dvl/data', DVLData, self.dvl_callback) self.depth_sub = rospy.Subscriber('/modcube/depth', FluidDepth, self.depth_callback) self.image_sub = rospy.Subscriber('/modcube/camera/image_raw', Image, self.image_callback) self.cloud_sub = rospy.Subscriber('/modcube/pointcloud', PointCloud2, self.cloud_callback) # State publisher self.nav_pub = rospy.Publisher('/modcube/nav_state', NavState, queue_size=10) # Fusion timer self.fusion_timer = rospy.Timer(rospy.Duration(0.02), self.fusion_callback) # 50 Hz # Sensor health monitoring self.sensor_health = { 'imu': {'last_update': None, 'status': 'unknown'}, 'dvl': {'last_update': None, 'status': 'unknown'}, 'depth': {'last_update': None, 'status': 'unknown'}, 'visual': {'last_update': None, 'status': 'unknown'} } rospy.loginfo(\"Multi-sensor fusion initialized\") def imu_callback(self, msg): \"\"\"Process IMU data.\"\"\" self.imu_data = { 'timestamp': msg.header.stamp, 'orientation': msg.orientation, 'angular_velocity': msg.angular_velocity, 'linear_acceleration': msg.linear_acceleration, 'orientation_covariance': np.array(msg.orientation_covariance).reshape(3, 3), 'angular_velocity_covariance': np.array(msg.angular_velocity_covariance).reshape(3, 3), 'linear_acceleration_covariance': np.array(msg.linear_acceleration_covariance).reshape(3, 3) } self.update_sensor_health('imu', msg.header.stamp) def dvl_callback(self, msg): \"\"\"Process DVL data.\"\"\" self.dvl_data = { 'timestamp': msg.header.stamp, 'velocity': msg.velocity, 'altitude': msg.altitude, 'beam_ranges': msg.beam_ranges, 'beam_velocities': msg.beam_velocities, 'status': msg.status } self.update_sensor_health('dvl', msg.header.stamp) def depth_callback(self, msg): \"\"\"Process depth sensor data.\"\"\" self.depth_data = { 'timestamp': msg.header.stamp, 'depth': msg.depth, 'pressure': msg.pressure, 'temperature': msg.temperature } self.update_sensor_health('depth', msg.header.stamp) def image_callback(self, msg): \"\"\"Process camera images for visual odometry.\"\"\" # Process visual odometry vo_result = self.visual_odometry.process_image(msg) if vo_result: self.visual_data = { 'timestamp': msg.header.stamp, 'pose_delta': vo_result['pose_delta'], 'confidence': vo_result['confidence'], 'features': vo_result['features'] } self.update_sensor_health('visual', msg.header.stamp) def cloud_callback(self, msg): \"\"\"Process point cloud data for obstacle detection and mapping.\"\"\" # Process point cloud for environmental awareness # This could include obstacle detection, SLAM, etc. pass def update_sensor_health(self, sensor_name, timestamp): \"\"\"Update sensor health status.\"\"\" self.sensor_health[sensor_name]['last_update'] = timestamp # Check if sensor is healthy (received data recently) current_time = rospy.Time.now() time_diff = (current_time - timestamp).to_sec() if time_diff &lt; 1.0: # Less than 1 second old self.sensor_health[sensor_name]['status'] = 'healthy' elif time_diff &lt; 5.0: # Less than 5 seconds old self.sensor_health[sensor_name]['status'] = 'degraded' else: self.sensor_health[sensor_name]['status'] = 'failed' def fusion_callback(self, event): \"\"\"Main sensor fusion loop.\"\"\" current_time = rospy.Time.now() # Prediction step self.ekf.predict(dt=0.02) # Update with available sensor data if self.imu_data and self.is_data_fresh(self.imu_data, current_time, 0.1): self.update_with_imu() if self.dvl_data and self.is_data_fresh(self.dvl_data, current_time, 0.5): self.update_with_dvl() if self.depth_data and self.is_data_fresh(self.depth_data, current_time, 1.0): self.update_with_depth() if self.visual_data and self.is_data_fresh(self.visual_data, current_time, 0.2): self.update_with_visual() # Publish fused navigation state self.publish_nav_state() def is_data_fresh(self, data, current_time, max_age): \"\"\"Check if sensor data is fresh enough to use.\"\"\" age = (current_time - data['timestamp']).to_sec() return age &lt; max_age def update_with_imu(self): \"\"\"Update EKF with IMU measurements.\"\"\" # Extract measurements orientation = self.imu_data['orientation'] angular_velocity = self.imu_data['angular_velocity'] linear_acceleration = self.imu_data['linear_acceleration'] # Convert quaternion to euler angles roll, pitch, yaw = self.quaternion_to_euler(orientation) # Measurement vector: [roll, pitch, yaw, wx, wy, wz, ax, ay, az] z_imu = np.array([ roll, pitch, yaw, angular_velocity.x, angular_velocity.y, angular_velocity.z, linear_acceleration.x, linear_acceleration.y, linear_acceleration.z ]) # Measurement covariance R_imu = np.block([ [self.imu_data['orientation_covariance'], np.zeros((3, 6))], [np.zeros((3, 3)), self.imu_data['angular_velocity_covariance'], np.zeros((3, 3))], [np.zeros((3, 6)), self.imu_data['linear_acceleration_covariance']] ]) # Update EKF self.ekf.update(z_imu, R_imu, measurement_model='imu') def update_with_dvl(self): \"\"\"Update EKF with DVL measurements.\"\"\" if self.dvl_data['status'] != 0: # Check DVL status return # Extract velocity measurements velocity = self.dvl_data['velocity'] # Measurement vector: [vx, vy, vz] z_dvl = np.array([velocity.x, velocity.y, velocity.z]) # Measurement covariance (simplified) R_dvl = np.diag([0.01, 0.01, 0.01]) # 1 cm/s standard deviation # Update EKF self.ekf.update(z_dvl, R_dvl, measurement_model='dvl') def update_with_depth(self): \"\"\"Update EKF with depth measurements.\"\"\" depth = self.depth_data['depth'] # Measurement vector: [z] z_depth = np.array([depth]) # Measurement covariance R_depth = np.array([[0.01]]) # 1 cm standard deviation # Update EKF self.ekf.update(z_depth, R_depth, measurement_model='depth') def update_with_visual(self): \"\"\"Update EKF with visual odometry measurements.\"\"\" if self.visual_data['confidence'] &lt; 0.5: # Low confidence return pose_delta = self.visual_data['pose_delta'] # Extract position and orientation changes dx = pose_delta['position']['x'] dy = pose_delta['position']['y'] dz = pose_delta['position']['z'] dyaw = pose_delta['orientation']['yaw'] # Measurement vector: [dx, dy, dz, dyaw] z_visual = np.array([dx, dy, dz, dyaw]) # Measurement covariance (based on confidence) confidence = self.visual_data['confidence'] base_variance = 0.1 / confidence # Higher variance for lower confidence R_visual = np.diag([base_variance, base_variance, base_variance, base_variance * 0.1]) # Update EKF self.ekf.update(z_visual, R_visual, measurement_model='visual') def publish_nav_state(self): \"\"\"Publish the fused navigation state.\"\"\" state = self.ekf.get_state() covariance = self.ekf.get_covariance() nav_msg = NavState() nav_msg.header.stamp = rospy.Time.now() nav_msg.header.frame_id = 'odom' # Position nav_msg.pose.pose.position.x = state[0] nav_msg.pose.pose.position.y = state[1] nav_msg.pose.pose.position.z = state[2] # Orientation (convert from euler to quaternion) nav_msg.pose.pose.orientation = self.euler_to_quaternion(state[9], state[10], state[11]) # Velocity nav_msg.twist.twist.linear.x = state[3] nav_msg.twist.twist.linear.y = state[4] nav_msg.twist.twist.linear.z = state[5] # Angular velocity nav_msg.twist.twist.angular.x = state[12] nav_msg.twist.twist.angular.y = state[13] nav_msg.twist.twist.angular.z = state[14] # Covariances (simplified) nav_msg.pose.covariance = covariance[:6, :6].flatten().tolist() + [0] * 30 nav_msg.twist.covariance = covariance[3:9, 3:9].flatten().tolist() + [0] * 30 self.nav_pub.publish(nav_msg) def quaternion_to_euler(self, q): \"\"\"Convert quaternion to euler angles.\"\"\" import math # Roll (x-axis rotation) sinr_cosp = 2 * (q.w * q.x + q.y * q.z) cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y) roll = math.atan2(sinr_cosp, cosr_cosp) # Pitch (y-axis rotation) sinp = 2 * (q.w * q.y - q.z * q.x) if abs(sinp) &gt;= 1: pitch = math.copysign(math.pi / 2, sinp) # Use 90 degrees if out of range else: pitch = math.asin(sinp) # Yaw (z-axis rotation) siny_cosp = 2 * (q.w * q.z + q.x * q.y) cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z) yaw = math.atan2(siny_cosp, cosy_cosp) return roll, pitch, yaw def euler_to_quaternion(self, roll, pitch, yaw): \"\"\"Convert euler angles to quaternion.\"\"\" import math from geometry_msgs.msg import Quaternion cy = math.cos(yaw * 0.5) sy = math.sin(yaw * 0.5) cp = math.cos(pitch * 0.5) sp = math.sin(pitch * 0.5) cr = math.cos(roll * 0.5) sr = math.sin(roll * 0.5) return Quaternion( x=sr * cp * cy - cr * sp * sy, y=cr * sp * cy + sr * cp * sy, z=cr * cp * sy - sr * sp * cy, w=cr * cp * cy + sr * sp * sy ) if __name__ == '__main__': try: fusion = MultiSensorFusion() rospy.spin() except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#sensor-integration",
    
    "relUrl": "/examples/#sensor-integration"
  },"66": {
    "doc": "Examples",
    "title": "Multi-Vehicle Coordination",
    "content": "Example 8: Formation Control . #!/usr/bin/env python \"\"\" Formation Control Example Demonstrates coordinated control of multiple ModCube vehicles in various formation patterns. \"\"\" import rospy import numpy as np from geometry_msgs.msg import Point, Pose, Twist from modcube_msgs.msg import FormationCommand, VehicleState from modcube_common.formation import FormationController class FormationControl: def __init__(self, vehicle_id, num_vehicles): rospy.init_node(f'formation_control_{vehicle_id}') self.vehicle_id = vehicle_id self.num_vehicles = num_vehicles # Formation controller self.formation_controller = FormationController(vehicle_id, num_vehicles) # Vehicle states self.vehicle_states = {} self.formation_command = None # Publishers and subscribers self.cmd_pub = rospy.Publisher(f'/modcube_{vehicle_id}/cmd_vel', Twist, queue_size=10) self.state_pub = rospy.Publisher('/formation/vehicle_states', VehicleState, queue_size=10) # Subscribe to other vehicles' states for i in range(num_vehicles): if i != vehicle_id: rospy.Subscriber(f'/modcube_{i}/nav_state', NavState, lambda msg, vid=i: self.vehicle_state_callback(msg, vid)) # Formation command subscriber rospy.Subscriber('/formation/command', FormationCommand, self.formation_command_callback) # Control timer self.control_timer = rospy.Timer(rospy.Duration(0.1), self.control_callback) rospy.loginfo(f\"Formation control initialized for vehicle {vehicle_id}\") def vehicle_state_callback(self, msg, vehicle_id): \"\"\"Update state of other vehicles.\"\"\" self.vehicle_states[vehicle_id] = { 'position': msg.pose.pose.position, 'velocity': msg.twist.twist.linear, 'timestamp': msg.header.stamp } def formation_command_callback(self, msg): \"\"\"Receive formation command.\"\"\" self.formation_command = msg rospy.loginfo(f\"Received formation command: {msg.formation_type}\") def control_callback(self, event): \"\"\"Main formation control loop.\"\"\" if not self.formation_command: return # Get current vehicle state current_state = self.get_current_state() if not current_state: return # Calculate formation control control_cmd = self.formation_controller.compute_control( current_state=current_state, neighbor_states=self.vehicle_states, formation_command=self.formation_command ) # Publish control command if control_cmd: self.cmd_pub.publish(control_cmd) def get_current_state(self): \"\"\"Get current vehicle state.\"\"\" # In practice, this would come from the navigation system # For this example, we'll simulate it return { 'position': Point(0, 0, -2), 'velocity': Point(0, 0, 0), 'timestamp': rospy.Time.now() } if __name__ == '__main__': import sys if len(sys.argv) &lt; 3: rospy.logerr(\"Usage: formation_control.py &lt;vehicle_id&gt; &lt;num_vehicles&gt;\") sys.exit(1) try: vehicle_id = int(sys.argv[1]) num_vehicles = int(sys.argv[2]) formation = FormationControl(vehicle_id, num_vehicles) rospy.spin() except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#multi-vehicle-coordination",
    
    "relUrl": "/examples/#multi-vehicle-coordination"
  },"67": {
    "doc": "Examples",
    "title": "Advanced Applications",
    "content": "Example 9: Adaptive Control . #!/usr/bin/env python \"\"\" Adaptive Control Example Demonstrates adaptive control algorithms that adjust to changing vehicle dynamics and environmental conditions. \"\"\" import rospy import numpy as np from modcube_msgs.msg import ControllerCommand, NavState from modcube_common.adaptive import AdaptiveController class AdaptiveControlSystem: def __init__(self): rospy.init_node('adaptive_control') # Adaptive controller self.adaptive_controller = AdaptiveController() # System identification self.system_id = SystemIdentification() # Data buffers self.control_history = [] self.state_history = [] # Publishers and subscribers self.cmd_pub = rospy.Publisher('/modcube/controller_command', ControllerCommand, queue_size=10) self.nav_sub = rospy.Subscriber('/modcube/nav_state', NavState, self.nav_callback) # Adaptation timer self.adapt_timer = rospy.Timer(rospy.Duration(1.0), self.adaptation_callback) rospy.loginfo(\"Adaptive control system initialized\") def nav_callback(self, msg): \"\"\"Process navigation state updates.\"\"\" # Store state history for system identification state = { 'timestamp': msg.header.stamp, 'position': msg.pose.pose.position, 'velocity': msg.twist.twist.linear, 'orientation': msg.pose.pose.orientation } self.state_history.append(state) # Limit history size if len(self.state_history) &gt; 1000: self.state_history.pop(0) def adaptation_callback(self, event): \"\"\"Perform parameter adaptation.\"\"\" if len(self.state_history) &lt; 10 or len(self.control_history) &lt; 10: return # Identify current system parameters identified_params = self.system_id.identify( states=self.state_history[-100:], controls=self.control_history[-100:] ) # Update controller parameters if identified_params: self.adaptive_controller.update_parameters(identified_params) rospy.loginfo(\"Controller parameters adapted\") class SystemIdentification: \"\"\"System identification for parameter estimation.\"\"\" def __init__(self): self.model_order = 2 self.forgetting_factor = 0.95 def identify(self, states, controls): \"\"\"Identify system parameters from data.\"\"\" # Simplified system identification # In practice, use more sophisticated methods if len(states) &lt; self.model_order + 1: return None # Extract position and velocity data positions = np.array([[s['position'].x, s['position'].y, s['position'].z] for s in states]) velocities = np.array([[s['velocity'].x, s['velocity'].y, s['velocity'].z] for s in states]) # Simple parameter estimation try: # Estimate damping and mass parameters damping = self.estimate_damping(velocities) mass = self.estimate_mass(velocities, controls) return { 'damping': damping, 'mass': mass, 'confidence': 0.8 } except: return None def estimate_damping(self, velocities): \"\"\"Estimate damping coefficients.\"\"\" # Simplified damping estimation return np.array([1.0, 1.0, 1.0]) def estimate_mass(self, velocities, controls): \"\"\"Estimate vehicle mass.\"\"\" # Simplified mass estimation return 50.0 # kg if __name__ == '__main__': try: adaptive_system = AdaptiveControlSystem() rospy.spin() except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#advanced-applications",
    
    "relUrl": "/examples/#advanced-applications"
  },"68": {
    "doc": "Examples",
    "title": "Custom Development",
    "content": "Example 10: Custom Mission Plugin . #!/usr/bin/env python \"\"\" Custom Mission Plugin Example Demonstrates how to create custom mission types by extending the base mission framework. \"\"\" import rospy from modcube_mission import BaseMission from modcube_common.motion import MotionClient from geometry_msgs.msg import Point class CustomSurveyMission(BaseMission): \"\"\"Custom survey mission with specific requirements.\"\"\" def __init__(self, survey_area, resolution=1.0): super().__init__() self.survey_area = survey_area self.resolution = resolution self.motion_client = MotionClient() # Mission-specific parameters self.altitude = -2.0 self.speed = 0.5 self.overlap = 0.3 rospy.loginfo(\"Custom survey mission initialized\") def execute(self): \"\"\"Execute the custom survey mission.\"\"\" rospy.loginfo(\"Starting custom survey mission\") try: # Generate survey pattern survey_points = self.generate_survey_pattern() # Execute survey for i, point in enumerate(survey_points): if self.is_aborted(): return False success = self.motion_client.goto_position( point.x, point.y, point.z ) if not success: rospy.logwarn(f\"Failed to reach survey point {i}\") continue # Perform survey at this point self.perform_survey_at_point(point) # Update progress progress = (i + 1) / len(survey_points) * 100 self.update_progress(progress) self.update_state('completed') return True except Exception as e: rospy.logerr(f\"Survey mission failed: {e}\") self.update_state('failed') return False def generate_survey_pattern(self): \"\"\"Generate survey waypoints.\"\"\" points = [] x_min, x_max = self.survey_area['x_range'] y_min, y_max = self.survey_area['y_range'] x_steps = int((x_max - x_min) / self.resolution) + 1 y_steps = int((y_max - y_min) / self.resolution) + 1 for i in range(x_steps): x = x_min + i * self.resolution if i % 2 == 0: # Even rows: bottom to top y_range = range(y_steps) else: # Odd rows: top to bottom y_range = range(y_steps - 1, -1, -1) for j in y_range: y = y_min + j * self.resolution points.append(Point(x, y, self.altitude)) return points def perform_survey_at_point(self, point): \"\"\"Perform survey operations at a specific point.\"\"\" # Custom survey operations rospy.sleep(2.0) # Simulate data collection time if __name__ == '__main__': try: rospy.init_node('custom_survey_mission') survey_area = { 'x_range': (0, 20), 'y_range': (0, 15) } mission = CustomSurveyMission(survey_area, resolution=2.0) success = mission.execute() if success: rospy.loginfo(\"Custom survey mission completed\") else: rospy.logwarn(\"Custom survey mission failed\") except rospy.ROSInterruptException: pass . ",
    "url": "/ModCube.github.io/examples/#custom-development",
    
    "relUrl": "/examples/#custom-development"
  },"69": {
    "doc": "Examples",
    "title": "Running the Examples",
    "content": "Prerequisites . | ROS Environment: Ensure ROS is properly installed and sourced | ModCube Workspace: Build and source the ModCube workspace | Simulation Environment: Launch Gazebo simulation if testing in simulation | . Basic Setup . # Source ROS and workspace source /opt/ros/melodic/setup.bash source ~/modcube_ws/devel/setup.bash # Launch simulation (optional) roslaunch modcube_sim_worlds umd.launch # Launch ModCube system roslaunch modcube_config system.launch . Running Individual Examples . # Example 1: Basic Position Control rosrun modcube_examples basic_position_control.py # Example 2: Velocity Control rosrun modcube_examples velocity_control.py # Example 3: Waypoint Navigation rosrun modcube_examples waypoint_navigation.py # Example 5: Search and Rescue Mission rosrun modcube_examples search_rescue_mission.py # Example 8: Formation Control (multiple terminals) rosrun modcube_examples formation_control.py 0 3 # Vehicle 0 of 3 rosrun modcube_examples formation_control.py 1 3 # Vehicle 1 of 3 rosrun modcube_examples formation_control.py 2 3 # Vehicle 2 of 3 . Monitoring and Debugging . # Monitor system status rostopic echo /modcube/nav_state rostopic echo /modcube/controller_command # Visualize in RViz rosrun rviz rviz -d $(rospack find modcube_config)/rviz/modcube.rviz # Check system diagnostics rosrun rqt_robot_monitor rqt_robot_monitor . ",
    "url": "/ModCube.github.io/examples/#running-the-examples",
    
    "relUrl": "/examples/#running-the-examples"
  },"70": {
    "doc": "Examples",
    "title": "Troubleshooting",
    "content": "Common Issues . | No response to commands . | Check if the controller is running | Verify topic names and message types | Ensure proper coordinate frames | . | Simulation not starting . | Check Gazebo installation | Verify world files and model paths | Check for conflicting processes | . | Sensor data not available . | Verify sensor plugins are loaded | Check topic remapping | Ensure proper sensor configuration | . | . Debug Commands . # List active topics rostopic list # Check message types rostopic type /modcube/nav_state # Monitor message frequency rostopic hz /modcube/imu/data # View node graph rosrun rqt_graph rqt_graph # Check parameter server rosparam list rosparam get /modcube/controller/pid_gains . ",
    "url": "/ModCube.github.io/examples/#troubleshooting",
    
    "relUrl": "/examples/#troubleshooting"
  },"71": {
    "doc": "Examples",
    "title": "Next Steps",
    "content": ". | Modify Examples: Adapt the examples to your specific requirements | Create Custom Missions: Use the mission framework to develop custom applications | Integrate Hardware: Connect real sensors and actuators | Performance Tuning: Optimize parameters for your specific use case | Advanced Features: Explore machine learning integration and advanced control algorithms | . For more detailed information, refer to the API Documentation and Tutorials. ",
    "url": "/ModCube.github.io/examples/#next-steps",
    
    "relUrl": "/examples/#next-steps"
  },"72": {
    "doc": "FAQ",
    "title": "Frequently Asked Questions",
    "content": "This page addresses common questions about the RS-ModCubes system, covering installation, configuration, troubleshooting, and usage. ",
    "url": "/ModCube.github.io/faq/#frequently-asked-questions",
    
    "relUrl": "/faq/#frequently-asked-questions"
  },"73": {
    "doc": "FAQ",
    "title": "Table of Contents",
    "content": ". | General Questions | Installation and Setup | Configuration | Hardware Integration | Simulation | Control and Navigation | Mission Planning | Troubleshooting | Performance and Optimization | Development and Customization | . ",
    "url": "/ModCube.github.io/faq/#table-of-contents",
    
    "relUrl": "/faq/#table-of-contents"
  },"74": {
    "doc": "FAQ",
    "title": "General Questions",
    "content": "Q: What is RS-ModCubes? . A: RS-ModCubes is a comprehensive robotic system designed for autonomous underwater vehicles (AUVs). It provides a complete software stack including control systems, navigation, mission planning, and simulation capabilities. The system is built on ROS (Robot Operating System) and supports both simulation and real hardware deployment. Q: What are the main features of RS-ModCubes? . A: Key features include: . | Advanced Control Systems: PID controllers, thruster management, and adaptive control | State Estimation: Multi-sensor fusion with IMU, DVL, depth sensors, and cameras | Mission Planning: Waypoint navigation, search patterns, and custom mission types | Simulation Environment: Gazebo-based underwater simulation with realistic physics | Hardware Integration: Support for various sensors and actuators | Modular Architecture: Extensible design for custom applications | . Q: What platforms does RS-ModCubes support? . A: RS-ModCubes is primarily designed for Linux systems and supports: . | Ubuntu 18.04 LTS (with ROS Melodic) | Ubuntu 20.04 LTS (with ROS Noetic) | Other Linux distributions with compatible ROS versions | . Q: Is RS-ModCubes open source? . A: Yes, RS-ModCubes is released under an open-source license. You can find the source code, contribute to development, and modify it according to your needs. ",
    "url": "/ModCube.github.io/faq/#general-questions",
    
    "relUrl": "/faq/#general-questions"
  },"75": {
    "doc": "FAQ",
    "title": "Installation and Setup",
    "content": "Q: What are the system requirements for RS-ModCubes? . A: Minimum requirements: . | OS: Ubuntu 18.04/20.04 LTS | RAM: 8GB (16GB recommended) | Storage: 20GB free space | CPU: Intel i5 or equivalent (i7 recommended) | GPU: NVIDIA GPU recommended for simulation | . Q: How do I install ROS for RS-ModCubes? . A: Follow these steps: . # For Ubuntu 18.04 (ROS Melodic) sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list' sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 sudo apt update sudo apt install ros-melodic-desktop-full # For Ubuntu 20.04 (ROS Noetic) sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list' sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 sudo apt update sudo apt install ros-noetic-desktop-full . Q: How do I build the RS-ModCubes workspace? . A: After cloning the repository: . # Create workspace mkdir -p ~/modcube_ws/src cd ~/modcube_ws/src # Clone repository git clone https://github.com/your-org/RS-ModCubes.git # Install dependencies cd ~/modcube_ws rosdep install --from-paths src --ignore-src -r -y # Build workspace catkin_make # Source workspace source devel/setup.bash . Q: I’m getting build errors. What should I do? . A: Common solutions: . | Check dependencies: rosdep check --from-paths src --ignore-src . | Clean and rebuild: catkin_make clean catkin_make . | Check ROS version compatibility: rosversion -d . | Update package lists: sudo apt update rosdep update . | . ",
    "url": "/ModCube.github.io/faq/#installation-and-setup",
    
    "relUrl": "/faq/#installation-and-setup"
  },"76": {
    "doc": "FAQ",
    "title": "Configuration",
    "content": "Q: How do I configure the vehicle parameters? . A: Vehicle parameters are configured in YAML files located in modcube_config/modcube_description/yaml/. Key files include: . | vehicle.yaml: Basic vehicle parameters (mass, dimensions) | thruster_manager.yaml: Thruster configuration | controller.yaml: Control system parameters | sensors.yaml: Sensor configurations | . Example vehicle configuration: . vehicle: mass: 50.0 # kg length: 1.5 # m width: 0.8 # m height: 0.6 # m center_of_mass: [0.0, 0.0, 0.0] center_of_buoyancy: [0.0, 0.0, 0.1] . Q: How do I tune the PID controller? . A: PID parameters can be tuned in several ways: . | Static configuration in controller.yaml: pid_gains: position: x: {p: 2.0, i: 0.1, d: 0.5} y: {p: 2.0, i: 0.1, d: 0.5} z: {p: 3.0, i: 0.2, d: 0.8} . | Dynamic reconfiguration: rosrun rqt_reconfigure rqt_reconfigure . | Service calls: rosservice call /modcube/controller/set_pid_gains \"gains: {...}\" . | . Q: How do I add a new sensor? . A: To add a new sensor: . | Add sensor configuration to sensors.yaml | Create sensor plugin (if needed) | Update launch files to include sensor | Modify sensor fusion if required | . Example sensor configuration: . sensors: new_sensor: type: \"custom_sensor\" topic: \"/modcube/new_sensor/data\" frame_id: \"new_sensor_link\" rate: 10.0 parameters: param1: value1 param2: value2 . ",
    "url": "/ModCube.github.io/faq/#configuration",
    
    "relUrl": "/faq/#configuration"
  },"77": {
    "doc": "FAQ",
    "title": "Hardware Integration",
    "content": "Q: What hardware is supported? . A: RS-ModCubes supports various hardware components: . Sensors: . | IMU: Xsens MTi series, VectorNav VN-100/200 | DVL: Teledyne RDI, Nortek | Depth sensors: Pressure-based depth sensors | Cameras: USB cameras, GigE cameras | Sonar: Forward-looking sonar, imaging sonar | . Actuators: . | Thrusters: BlueRobotics T100/T200, VideoRay thrusters | Servos: Standard PWM servos | Lights: LED arrays, strobes | . Q: How do I connect an IMU? . A: IMU integration steps: . | Physical connection: Connect IMU via USB/Serial/Ethernet | Install driver: Install manufacturer’s ROS driver | Configure parameters: imu: device: \"/dev/ttyUSB0\" frame_id: \"imu_link\" rate: 100 . | Update launch file: &lt;node name=\"imu_driver\" pkg=\"imu_driver\" type=\"imu_node\"&gt; &lt;rosparam file=\"$(find modcube_config)/yaml/imu.yaml\"/&gt; &lt;/node&gt; . | . Q: How do I configure thrusters? . A: Thruster configuration involves: . | Define thruster layout in thruster_manager.yaml: ```yaml thrusters: . | id: 0 position: [0.3, 0.2, 0.0] orientation: [0.0, 0.0, 0.0] max_thrust: 50.0 # N | id: 1 position: [0.3, -0.2, 0.0] orientation: [0.0, 0.0, 0.0] max_thrust: 50.0 # N ``` | . | Configure thruster allocation matrix | Set up hardware interface | . Q: My sensors are not publishing data. What should I check? . A: Troubleshooting steps: . | Check physical connections | Verify device permissions: sudo chmod 666 /dev/ttyUSB0 . | Check driver installation: rospack find sensor_driver_package . | Monitor topics: rostopic list | grep sensor rostopic echo /sensor/topic . | Check launch file configuration | Review log files: roscd &amp;&amp; cd ../log . | . ",
    "url": "/ModCube.github.io/faq/#hardware-integration",
    
    "relUrl": "/faq/#hardware-integration"
  },"78": {
    "doc": "FAQ",
    "title": "Simulation",
    "content": "Q: How do I start the simulation? . A: To launch the simulation: . # Source workspace source ~/modcube_ws/devel/setup.bash # Launch simulation world roslaunch modcube_sim_worlds umd.launch # In another terminal, launch vehicle roslaunch modcube_config system.launch . Q: The simulation is running slowly. How can I improve performance? . A: Performance optimization tips: . | Reduce physics update rate: &lt;physics type=\"ode\"&gt; &lt;max_step_size&gt;0.01&lt;/max_step_size&gt; &lt;real_time_factor&gt;1.0&lt;/real_time_factor&gt; &lt;/physics&gt; . | Disable unnecessary sensors | Use lower resolution meshes | Reduce GUI rendering: roslaunch modcube_sim_worlds umd.launch gui:=false . | Enable GPU acceleration | . Q: How do I create a custom simulation world? . A: To create a custom world: . | Create world file in modcube_sim_worlds/worlds/: &lt;?xml version=\"1.0\"?&gt; &lt;sdf version=\"1.6\"&gt; &lt;world name=\"custom_world\"&gt; &lt;!-- Add models, lighting, physics --&gt; &lt;/world&gt; &lt;/sdf&gt; . | Create launch file: &lt;launch&gt; &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt; &lt;arg name=\"world_name\" value=\"$(find modcube_sim_worlds)/worlds/custom_world.world\"/&gt; &lt;/include&gt; &lt;/launch&gt; . | Add custom models to modcube_sim_worlds/models/ | . Q: How do I add obstacles to the simulation? . A: Add obstacles by: . | Creating SDF models | Adding to world file: &lt;include&gt; &lt;uri&gt;model://obstacle_model&lt;/uri&gt; &lt;pose&gt;10 5 -2 0 0 0&lt;/pose&gt; &lt;/include&gt; . | Using Gazebo GUI to place models interactively | . ",
    "url": "/ModCube.github.io/faq/#simulation",
    
    "relUrl": "/faq/#simulation"
  },"79": {
    "doc": "FAQ",
    "title": "Control and Navigation",
    "content": "Q: The vehicle is not responding to commands. What should I check? . A: Troubleshooting steps: . | Check controller status: rostopic echo /modcube/controller/status . | Verify command topics: rostopic list | grep cmd rostopic echo /modcube/controller_command . | Check thruster allocation: rostopic echo /modcube/thrusters/commands . | Verify coordinate frames: rosrun tf tf_echo odom base_link . | Check parameter values: rosparam get /modcube/controller/ . | . Q: How do I switch between control modes? . A: Control modes can be switched using: . | Service calls: rosservice call /modcube/controller/set_mode \"mode: 1\" # Position control rosservice call /modcube/controller/set_mode \"mode: 2\" # Velocity control . | Command messages: cmd = ControllerCommand() cmd.mode = 1 # Position control cmd_pub.publish(cmd) . | Dynamic reconfigure: rosrun rqt_reconfigure rqt_reconfigure . | . Q: How do I implement custom control algorithms? . A: To implement custom controllers: . | Create controller class inheriting from base controller | Implement control logic: class CustomController(BaseController): def compute_control(self, state, setpoint): # Custom control algorithm return control_output . | Register controller in the controller manager | Configure parameters in YAML files | . ",
    "url": "/ModCube.github.io/faq/#control-and-navigation",
    
    "relUrl": "/faq/#control-and-navigation"
  },"80": {
    "doc": "FAQ",
    "title": "Mission Planning",
    "content": "Q: How do I create a simple waypoint mission? . A: Create a waypoint mission: . from modcube_mission import WaypointMission from geometry_msgs.msg import Point # Define waypoints waypoints = [ Point(0, 0, -2), Point(10, 0, -2), Point(10, 10, -2), Point(0, 10, -2) ] # Create and execute mission mission = WaypointMission(waypoints) success = mission.execute() . Q: How do I implement custom mission types? . A: Extend the base mission class: . from modcube_mission import BaseMission class CustomMission(BaseMission): def __init__(self, custom_params): super().__init__() self.custom_params = custom_params def execute(self): # Implement custom mission logic try: # Mission execution code self.update_state('completed') return True except Exception as e: self.update_state('failed') return False . Q: How do I monitor mission progress? . A: Monitor missions using: . | Mission status topic: rostopic echo /modcube/mission/status . | RViz visualization | Custom monitoring scripts: def mission_status_callback(msg): print(f\"Mission: {msg.state}, Progress: {msg.progress}%\") rospy.Subscriber('/modcube/mission/status', MissionStatus, mission_status_callback) . | . ",
    "url": "/ModCube.github.io/faq/#mission-planning",
    
    "relUrl": "/faq/#mission-planning"
  },"81": {
    "doc": "FAQ",
    "title": "Troubleshooting",
    "content": "Q: ROS nodes are not communicating. What should I check? . A: Communication troubleshooting: . | Check ROS master: echo $ROS_MASTER_URI rosnode list . | Verify network configuration: echo $ROS_IP echo $ROS_HOSTNAME . | Check topic connections: rostopic info /topic_name rosnode info /node_name . | Monitor network traffic: rostopic bw /topic_name rostopic hz /topic_name . | . Q: The system crashes frequently. How do I debug? . A: Debugging crashes: . | Check log files: roscd &amp;&amp; cd ../log tail -f latest/rosout.log . | Use debugging tools: gdb --args rosrun package_name node_name valgrind rosrun package_name node_name . | Monitor system resources: htop iotop . | Check for memory leaks | Review error messages in terminal output | . Q: Sensor data is noisy or unreliable. What can I do? . A: Improve sensor data quality: . | Check physical connections | Implement filtering: from scipy.signal import butter, filtfilt def low_pass_filter(data, cutoff, fs): nyquist = 0.5 * fs normal_cutoff = cutoff / nyquist b, a = butter(6, normal_cutoff, btype='low', analog=False) return filtfilt(b, a, data) . | Calibrate sensors | Adjust sensor fusion parameters | Check environmental conditions | . ",
    "url": "/ModCube.github.io/faq/#troubleshooting",
    
    "relUrl": "/faq/#troubleshooting"
  },"82": {
    "doc": "FAQ",
    "title": "Performance and Optimization",
    "content": "Q: How can I improve system performance? . A: Performance optimization strategies: . | Optimize control loop rates: control_frequency: 50 # Hz estimation_frequency: 100 # Hz . | Use efficient data structures | Minimize memory allocations | Profile code performance: perf record rosrun package_name node_name perf report . | Optimize ROS communication: . | Use appropriate queue sizes | Minimize message size | Use efficient serialization | . | . Q: How do I monitor system performance? . A: Performance monitoring tools: . | ROS diagnostics: rosrun rqt_robot_monitor rqt_robot_monitor . | System monitoring: rosrun rqt_top rqt_top . | Custom performance metrics: import time start_time = time.time() # ... code to measure ... execution_time = time.time() - start_time . | Network monitoring: rostopic bw /topic_name rostopic delay /topic_name . | . ",
    "url": "/ModCube.github.io/faq/#performance-and-optimization",
    
    "relUrl": "/faq/#performance-and-optimization"
  },"83": {
    "doc": "FAQ",
    "title": "Development and Customization",
    "content": "Q: How do I contribute to RS-ModCubes development? . A: Contributing guidelines: . | Fork the repository on GitHub | Create feature branch: git checkout -b feature/new-feature . | Follow coding standards: . | Use consistent naming conventions | Add documentation and comments | Write unit tests | . | Submit pull request with detailed description | Respond to review feedback | . Q: How do I create custom plugins? . A: Plugin development: . | Create plugin class: #include &lt;pluginlib/class_list_macros.h&gt; #include &lt;modcube_common/base_plugin.h&gt; class CustomPlugin : public modcube_common::BasePlugin { public: void initialize() override { // Plugin initialization } }; PLUGINLIB_EXPORT_CLASS(CustomPlugin, modcube_common::BasePlugin) . | Create plugin description: &lt;library path=\"lib/libcustom_plugin\"&gt; &lt;class name=\"custom_plugin/CustomPlugin\" type=\"CustomPlugin\" base_class_type=\"modcube_common::BasePlugin\"&gt; &lt;description&gt;Custom plugin description&lt;/description&gt; &lt;/class&gt; &lt;/library&gt; . | Register plugin in package.xml | . Q: How do I add support for new hardware? . A: Hardware integration steps: . | Create hardware interface: class NewHardwareInterface : public hardware_interface::RobotHW { // Implement hardware interface }; . | Develop ROS driver | Create configuration files | Add launch file integration | Write documentation and examples | Test thoroughly | . Q: Where can I find more help? . A: Additional resources: . | Documentation: Check the official documentation | GitHub Issues: Report bugs and request features | Community Forum: Join discussions with other users | Email Support: Contact the development team | Video Tutorials: Watch demonstration videos | Academic Papers: Read research publications | . ",
    "url": "/ModCube.github.io/faq/#development-and-customization",
    
    "relUrl": "/faq/#development-and-customization"
  },"84": {
    "doc": "FAQ",
    "title": "Still Have Questions?",
    "content": "If you can’t find the answer to your question here, please: . | Search the documentation for related topics | Check GitHub issues for similar problems | Ask on the community forum | Contact the development team | . We’re here to help you succeed with RS-ModCubes! . ",
    "url": "/ModCube.github.io/faq/#still-have-questions",
    
    "relUrl": "/faq/#still-have-questions"
  },"85": {
    "doc": "FAQ",
    "title": "FAQ",
    "content": " ",
    "url": "/ModCube.github.io/faq/",
    
    "relUrl": "/faq/"
  },"86": {
    "doc": "Home",
    "title": "RS-ModCubes: Self-Reconfigurable Modular Underwater Robots",
    "content": ". ",
    "url": "/ModCube.github.io/#rs-modcubes-self-reconfigurable-modular-underwater-robots",
    
    "relUrl": "/#rs-modcubes-self-reconfigurable-modular-underwater-robots"
  },"87": {
    "doc": "Home",
    "title": "Project Overview",
    "content": "RS-ModCubes is a comprehensive simulation, control, and mission planning framework for self-reconfigurable, scalable modular underwater robots. The system can simulate and control multiple cubic robot modules that can autonomously reconfigure to form different configurations for various underwater operations. Core Features . | Modular Self-Reconfiguration: Dynamic configuration adaptation during missions | Underwater Physics Simulation: Comprehensive hydrodynamic modeling based on Gazebo | Mission Planning: Autonomous navigation and mission execution | Teleoperation Support: Real-time human-robot interaction | Multi-Robot Coordination: Scalable swarm behavior implementation | Extensible Framework: ROS-based modular architecture | . ",
    "url": "/ModCube.github.io/#project-overview",
    
    "relUrl": "/#project-overview"
  },"88": {
    "doc": "Home",
    "title": "System Architecture",
    "content": "Overall Architecture Diagram . graph TB A[Mission Planning Layer] --&gt; B[Control Layer] B --&gt; C[Simulation Layer] C --&gt; D[Hardware Interface Layer] A --&gt; E[modcube_mission] B --&gt; F[modcube_common] C --&gt; G[modcube_sim] D --&gt; H[modcube_vehicle] E --&gt; I[Path Planning] E --&gt; J[Mission Execution] F --&gt; K[Controllers] F --&gt; L[State Estimation] G --&gt; M[Gazebo Plugins] G --&gt; N[Physics Models] H --&gt; O[Sensor Drivers] H --&gt; P[Actuator Control] . Package Structure Analysis . Core Framework Packages . | Package Name | Functionality | Main Components | . | modcube_common | Core utilities and shared libraries | Controllers, planners, state estimation, dynamics | . | modcube_config | Configuration files and robot descriptions | URDF models, parameter files, launch configurations | . | modcube_mission | Mission execution and teleoperation | Mission planning, teleoperation interface, system launch files | . | modcube_msgs | Custom ROS message definitions | Inter-module communication protocols | . Simulation Packages . | Package Name | Functionality | Main Components | . | modcube_sim | Gazebo simulation interface | Simulation launch files, environment setup | . | modcube_sim_gazebo_plugins | Custom Gazebo plugins | Thruster dynamics, navigation state, sensor models | . | modcube_sim_worlds | Simulation environments | Underwater worlds, obstacle courses, test scenarios | . Hardware Interface . | Package Name | Functionality | Main Components | . | modcube_vehicle | Vehicle-specific hardware drivers | IMU, thrusters, sensors, actuator control | . Dependencies . | Package Name | Functionality | Main Components | . | uuv_simulator | UUV simulation framework | Hydrodynamic models, sensor plugins, control algorithms | . ",
    "url": "/ModCube.github.io/#system-architecture",
    
    "relUrl": "/#system-architecture"
  },"89": {
    "doc": "Home",
    "title": "Technical Implementation Details",
    "content": "1. Control System . PID Controller Implementation . | Position Control: 6-DOF PID controller supporting position and attitude control | Thruster Allocation: Force allocation algorithm based on thruster configuration matrix | Dynamics Compensation: Model-based feedforward control | . # PID Controller Core Implementation class PIDController: def __init__(self, kp, ki, kd): self.kp = kp self.ki = ki self.kd = kd self.prev_error = 0 self.integral = 0 def compute(self, error, dt): self.integral += error * dt derivative = (error - self.prev_error) / dt if dt &gt; 0 else 0 output = self.kp * error + self.ki * self.integral + self.kd * derivative self.prev_error = error return output . Thruster Management . | Thruster Configuration: Support for 8-thruster and 32-thruster configurations | Force Allocation Matrix: Automatic calculation of Thruster Allocation Matrix (TAM) | Fault Handling: Thruster fault detection and compensation | . 2. State Estimation . Sensor Fusion . | IMU Data Processing: Xsens IMU data fusion | DVL Velocity Estimation: Teledyne DVL Doppler velocity measurement | Depth Sensor: Pressure sensor depth measurement | Extended Kalman Filter: EKF state estimation implementation | . 3. Mission Planning . Trajectory Generation . | Minimum Snap Trajectory: Smooth trajectory generation algorithm | Path Following: PID-based path following control | Obstacle Avoidance: Dynamic obstacle avoidance planning | . Mission Management . | Task Scheduling: State machine-based task execution | Resource Management: Sensor and actuator resource allocation | Fault Recovery: Mission failure handling and recovery mechanisms | . 4. Simulation Environment . Physics Modeling . | Hydrodynamics: Underwater dynamics based on Fossen model | Thruster Model: T200 thruster dynamics simulation | Sensor Simulation: IMU, DVL, camera and other sensor simulations | . Environment Models . | Underwater Scenes: Various underwater environment models | Mission Props: Gates, buoys, targets and other mission-related models | Current Simulation: Ocean current and disturbance simulation | . ",
    "url": "/ModCube.github.io/#technical-implementation-details",
    
    "relUrl": "/#technical-implementation-details"
  },"90": {
    "doc": "Home",
    "title": "Configuration System",
    "content": "Robot Configuration . Single Module Configuration (default.xacro) . | 8-thruster configuration | Basic sensor suite | Standard control parameters | . Four Module Configuration (default_4_modcube.xacro) . | 32-thruster configuration | Enhanced sensor suite | Multi-module coordinated control | . Parameter Configuration Files . Control Parameters (controller.yaml) . controller: kp: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0] ki: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1] kd: [0.01, 0.01, 0.01, 0.01, 0.01, 0.01] max_wrench: [100, 100, 100, 50, 50, 50] . Thruster Configuration (thruster_manager.yaml) . frequency: 50 thruster_ids: [0, 1, 2, 3, 4, 5, 6, 7] . ",
    "url": "/ModCube.github.io/#configuration-system",
    
    "relUrl": "/#configuration-system"
  },"91": {
    "doc": "Home",
    "title": "Usage Guide",
    "content": "Quick Start . 1. Environment Setup . # Install ROS dependencies sudo apt-get install ros-$ROS_DISTRO-gazebo-* sudo apt-get install ros-$ROS_DISTRO-uuv-simulator # Clone project git clone https://github.com/your-username/ModCube.git cd ModCube # Build workspace catkin build source devel/setup.bash . 2. Launch Simulation . # Launch basic simulation roslaunch modcube_sim kingfisher_umd_sim.launch # Launch multi-robot simulation roslaunch modcube_sim multi_robot_sim.launch num_robots:=4 . 3. Mission Execution . # Launch teleoperation interface roslaunch modcube_mission teleop_mission.launch # Launch autonomous mission roslaunch modcube_mission autonomous_mission.launch mission_file:=sample_mission.yaml . 4. Navigation Commands . # Set navigation target rostopic pub /modcube/goto geometry_msgs/PoseStamped \" header: frame_id: 'world' pose: position: {x: 2.0, y: 2.0, z: 2.0} orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}\" # Or use simplified command goto 2 2 2 1 1 1 1 . Advanced Configuration . Custom Robot Configuration . # Edit robot description roscd modcube_config/modcube_sim_description/urdf/ # Modify default.xacro for single robot # Modify default_4_modcube.xacro for four-module configuration . Mission Planning Configuration . # sample_mission.yaml mission: name: \"exploration_mission\" waypoints: - {x: 0, y: 0, z: 0} - {x: 5, y: 0, z: -2} - {x: 5, y: 5, z: -2} tasks: - type: \"survey\" duration: 30 - type: \"sample_collection\" target: \"object_1\" . Control Parameter Tuning . # View current parameters rosparam list /modcube/ # Set PID gains rosparam set /modcube/controller/pid_gains/kp 1.0 rosparam set /modcube/controller/pid_gains/ki 0.1 rosparam set /modcube/controller/pid_gains/kd 0.01 . ",
    "url": "/ModCube.github.io/#usage-guide",
    
    "relUrl": "/#usage-guide"
  },"92": {
    "doc": "Home",
    "title": "Testing and Validation",
    "content": "Unit Testing . # Run all tests catkin run_tests # Run specific package tests catkin run_tests modcube_common . Simulation Validation . # Test basic functionality rostest modcube_sim basic_simulation.test # Test multi-robot scenarios rostest modcube_sim multi_robot.test . ",
    "url": "/ModCube.github.io/#testing-and-validation",
    
    "relUrl": "/#testing-and-validation"
  },"93": {
    "doc": "Home",
    "title": "Performance Metrics",
    "content": "The framework has been validated with the following performance characteristics: . | Real-time Factor: 0.8-1.0 (depending on system configuration) | Control Frequency: 50-100 Hz | Simulation Accuracy: Hydrodynamic force error &lt;5% | Multi-robot Scalability: Tested with up to 8 robots running simultaneously | . ",
    "url": "/ModCube.github.io/#performance-metrics",
    
    "relUrl": "/#performance-metrics"
  },"94": {
    "doc": "Home",
    "title": "Development Guide",
    "content": "Code Standards . | Follow ROS C++ style guide | Use clang-format for code formatting | Include comprehensive unit tests | Document public APIs using Doxygen | . Contribution Guidelines . | Fork the project repository | Create a feature branch | Commit your changes | Create a Pull Request | . ",
    "url": "/ModCube.github.io/#development-guide",
    
    "relUrl": "/#development-guide"
  },"95": {
    "doc": "Home",
    "title": "Citation",
    "content": "If you use RS-ModCubes in your research, please cite our work: . @article{zheng2025rs, title={Rs-modcubes: Self-reconfigurable, scalable, modular cubic robots for underwater operations}, author={Zheng, Jiaxi and Dai, Guangmin and He, Botao and Mu, Zhaoyang and Meng, Zhaochen and Zhang, Tianyi and Zhi, Weiming and Fan, Dixia}, journal={IEEE Robotics and Automation Letters}, year={2025}, publisher={IEEE} } . ",
    "url": "/ModCube.github.io/#citation",
    
    "relUrl": "/#citation"
  },"96": {
    "doc": "Home",
    "title": "License",
    "content": "This project is licensed under the MIT License - see the LICENSE file for details. ",
    "url": "/ModCube.github.io/#license",
    
    "relUrl": "/#license"
  },"97": {
    "doc": "Home",
    "title": "Acknowledgments",
    "content": ". | CMU TartanAUV team for the base Kingfisher framework | UUV Simulator community for underwater simulation tools | ROS community for robotics middleware | . ",
    "url": "/ModCube.github.io/#acknowledgments",
    
    "relUrl": "/#acknowledgments"
  },"98": {
    "doc": "Home",
    "title": "Related Projects",
    "content": ". | UUV Simulator | TartanAUV | ROS | Gazebo | . If you find this project useful, please consider giving it a star! . ",
    "url": "/ModCube.github.io/#related-projects",
    
    "relUrl": "/#related-projects"
  },"99": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/ModCube.github.io/",
    
    "relUrl": "/"
  },"100": {
    "doc": "Installation Guide",
    "title": "Installation Guide",
    "content": "This guide provides step-by-step instructions for installing and configuring the RS-ModCubes system on your development environment. ",
    "url": "/ModCube.github.io/installation/",
    
    "relUrl": "/installation/"
  },"101": {
    "doc": "Installation Guide",
    "title": "Prerequisites",
    "content": "System Requirements . Operating System: . | Ubuntu 18.04 LTS (Bionic Beaver) - Recommended | Ubuntu 20.04 LTS (Focal Fossa) - Supported | Other Linux distributions may work but are not officially supported | . Hardware Requirements: . | CPU: Intel i5 or AMD equivalent (minimum), Intel i7 or better (recommended) | RAM: 8 GB (minimum), 16 GB or more (recommended) | Storage: 20 GB free space (minimum), SSD recommended | Graphics: Dedicated GPU recommended for Gazebo simulation | . Software Dependencies . ROS Distribution: . | ROS Melodic (Ubuntu 18.04) | ROS Noetic (Ubuntu 20.04) | . Required Packages: . | Python 2.7 or 3.x | Git | CMake 3.10+ | GCC/G++ compiler | Gazebo 9.0+ | . ",
    "url": "/ModCube.github.io/installation/#prerequisites",
    
    "relUrl": "/installation/#prerequisites"
  },"102": {
    "doc": "Installation Guide",
    "title": "Installation Steps",
    "content": "Step 1: Install ROS . For Ubuntu 18.04 (ROS Melodic) . # Setup sources.list sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list' # Setup keys sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 # Update package index sudo apt update # Install ROS Melodic Desktop Full sudo apt install ros-melodic-desktop-full # Initialize rosdep sudo rosdep init rosdep update # Setup environment echo \"source /opt/ros/melodic/setup.bash\" &gt;&gt; ~/.bashrc source ~/.bashrc # Install additional tools sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential . For Ubuntu 20.04 (ROS Noetic) . # Setup sources.list sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list' # Setup keys sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 # Update package index sudo apt update # Install ROS Noetic Desktop Full sudo apt install ros-noetic-desktop-full # Initialize rosdep sudo rosdep init rosdep update # Setup environment echo \"source /opt/ros/noetic/setup.bash\" &gt;&gt; ~/.bashrc source ~/.bashrc # Install additional tools sudo apt install python3-rosinstall python3-rosinstall-generator python3-wstool build-essential . Step 2: Install Additional Dependencies . # Install Gazebo (if not already installed with ROS) sudo apt install gazebo9 libgazebo9-dev # Install additional ROS packages sudo apt install ros-$ROS_DISTRO-gazebo-ros-pkgs ros-$ROS_DISTRO-gazebo-ros-control sudo apt install ros-$ROS_DISTRO-joint-state-publisher ros-$ROS_DISTRO-robot-state-publisher sudo apt install ros-$ROS_DISTRO-xacro ros-$ROS_DISTRO-tf2-tools sudo apt install ros-$ROS_DISTRO-rqt ros-$ROS_DISTRO-rqt-common-plugins # Install Python dependencies sudo apt install python3-pip pip3 install numpy scipy matplotlib # Install Git LFS (for large files) sudo apt install git-lfs git lfs install . Step 3: Create Workspace . # Create catkin workspace mkdir -p ~/modcube_ws/src cd ~/modcube_ws/ catkin_make # Setup workspace environment echo \"source ~/modcube_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc source ~/.bashrc . Step 4: Clone Repository . # Navigate to workspace source directory cd ~/modcube_ws/src # Clone the ModCube repository git clone https://github.com/jiaxi-zheng/ModCube.git # Navigate to the cloned repository cd ModCube # Initialize and update submodules git submodule init git submodule update . Step 5: Install Package Dependencies . # Navigate to workspace root cd ~/modcube_ws # Install dependencies using rosdep rosdep install --from-paths src --ignore-src -r -y # Install additional Python dependencies cd src/ModCube pip3 install -r requirements.txt # If requirements.txt exists . Step 6: Build the Workspace . # Navigate to workspace root cd ~/modcube_ws # Build all packages catkin_make # Alternative: Build with specific number of jobs catkin_make -j4 # Source the workspace source devel/setup.bash . ",
    "url": "/ModCube.github.io/installation/#installation-steps",
    
    "relUrl": "/installation/#installation-steps"
  },"103": {
    "doc": "Installation Guide",
    "title": "Configuration",
    "content": "Environment Setup . Add the following to your ~/.bashrc file: . # ROS Environment source /opt/ros/$ROS_DISTRO/setup.bash source ~/modcube_ws/devel/setup.bash # Gazebo Environment export GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:~/modcube_ws/src/ModCube/packages/modcube_sim_worlds/models export GAZEBO_RESOURCE_PATH=$GAZEBO_RESOURCE_PATH:~/modcube_ws/src/ModCube/packages/modcube_sim_worlds # ModCube specific environment variables export MODCUBE_CONFIG_PATH=~/modcube_ws/src/ModCube/packages/modcube_config export MODCUBE_WORKSPACE=~/modcube_ws . Network Configuration . For multi-machine setups: . # Set ROS Master URI (replace with actual master IP) export ROS_MASTER_URI=http://192.168.1.100:11311 # Set ROS IP (replace with your machine's IP) export ROS_IP=192.168.1.101 . ",
    "url": "/ModCube.github.io/installation/#configuration",
    
    "relUrl": "/installation/#configuration"
  },"104": {
    "doc": "Installation Guide",
    "title": "Verification",
    "content": "Test Basic Installation . # Test ROS installation roscore &amp; rostopic list killall roscore # Test Gazebo installation gazebo --version # Test ModCube packages rospack find modcube_common rospack find modcube_mission rospack find modcube_vehicle . Run Simple Simulation . # Launch basic simulation roslaunch modcube_mission system.launch model_name:=modcube simulated:=true # In another terminal, check running nodes rosnode list # Check topics rostopic list . ",
    "url": "/ModCube.github.io/installation/#verification",
    
    "relUrl": "/installation/#verification"
  },"105": {
    "doc": "Installation Guide",
    "title": "Hardware Setup (Optional)",
    "content": "IMU Configuration . For Xsens IMU systems: . # Install Xsens drivers (follow manufacturer instructions) # Configure USB permissions sudo usermod -a -G dialout $USER # Create udev rules for IMU sudo nano /etc/udev/rules.d/99-xsens.rules # Add: SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"2639\", MODE=\"0666\" # Reload udev rules sudo udevadm control --reload-rules sudo udevadm trigger . DVL Configuration . For Teledyne DVL systems: . # Configure serial port permissions sudo usermod -a -G dialout $USER # Create udev rules for DVL sudo nano /etc/udev/rules.d/99-teledyne.rules # Add appropriate rules based on your DVL model # Test serial communication sudo apt install minicom minicom -D /dev/ttyUSB0 -b 115200 . Thruster Configuration . For Pololu Maestro PWM controllers: . # Install Pololu software wget https://www.pololu.com/file/0J315/pololu-usb-sdk-120404.tar.gz tar -xzf pololu-usb-sdk-120404.tar.gz cd pololu-usb-sdk-120404 make sudo make install # Configure USB permissions sudo nano /etc/udev/rules.d/99-pololu.rules # Add: SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"1ffb\", MODE=\"0666\" # Reload udev rules sudo udevadm control --reload-rules . ",
    "url": "/ModCube.github.io/installation/#hardware-setup-optional",
    
    "relUrl": "/installation/#hardware-setup-optional"
  },"106": {
    "doc": "Installation Guide",
    "title": "Troubleshooting",
    "content": "Common Issues . Issue: catkin_make fails with dependency errors . # Solution: Install missing dependencies rosdep install --from-paths src --ignore-src -r -y . Issue: Gazebo crashes or runs slowly . # Solution: Check graphics drivers and reduce simulation complexity export LIBGL_ALWAYS_SOFTWARE=1 # For software rendering . Issue: Cannot find ModCube packages . # Solution: Source the workspace source ~/modcube_ws/devel/setup.bash . Issue: Permission denied for hardware devices . # Solution: Add user to appropriate groups sudo usermod -a -G dialout $USER sudo usermod -a -G plugdev $USER # Log out and log back in . Debug Commands . # Check ROS environment env | grep ROS # Check package dependencies rospack depends modcube_common # Check for missing dependencies rosdep check --from-paths src --ignore-src # Verbose catkin build catkin_make --verbose # Check Gazebo plugins gazebo --verbose . Log Files . Important log locations: . | ROS logs: ~/.ros/log/ | Gazebo logs: ~/.gazebo/ | System logs: /var/log/syslog | . ",
    "url": "/ModCube.github.io/installation/#troubleshooting",
    
    "relUrl": "/installation/#troubleshooting"
  },"107": {
    "doc": "Installation Guide",
    "title": "Performance Optimization",
    "content": "Build Optimization . # Use multiple cores for building catkin_make -j$(nproc) # Release build for better performance catkin_make -DCMAKE_BUILD_TYPE=Release . Runtime Optimization . # Increase ROS message buffer sizes export ROSCONSOLE_CONFIG_FILE=~/modcube_ws/src/ModCube/config/rosconsole.conf # Optimize Gazebo performance export GAZEBO_MASTER_URI=http://localhost:11345 export GAZEBO_MODEL_DATABASE_URI=http://gazebosim.org/models . ",
    "url": "/ModCube.github.io/installation/#performance-optimization",
    
    "relUrl": "/installation/#performance-optimization"
  },"108": {
    "doc": "Installation Guide",
    "title": "Next Steps",
    "content": "After successful installation: . | Read the Tutorials to learn basic system usage | Explore Examples for practical applications | Review API Documentation for development | Join the community for support and contributions | . ",
    "url": "/ModCube.github.io/installation/#next-steps",
    
    "relUrl": "/installation/#next-steps"
  },"109": {
    "doc": "Installation Guide",
    "title": "Support",
    "content": "If you encounter issues during installation: . | Check the Troubleshooting section | Search existing GitHub Issues | Create a new issue with detailed error information | Contact the development team | . ",
    "url": "/ModCube.github.io/installation/#support",
    
    "relUrl": "/installation/#support"
  },"110": {
    "doc": "Installation Guide",
    "title": "Contributing",
    "content": "Interested in contributing? See our Contributing Guidelines for development setup and contribution process. ",
    "url": "/ModCube.github.io/installation/#contributing",
    
    "relUrl": "/installation/#contributing"
  },"111": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": "This section provides comprehensive tutorials for using the RS-ModCubes system, from basic operations to advanced configurations. ",
    "url": "/ModCube.github.io/tutorials/",
    
    "relUrl": "/tutorials/"
  },"112": {
    "doc": "Tutorials",
    "title": "Table of Contents",
    "content": ". | Quick Start | Basic Simulation | Control System Tutorial | Mission Planning | Hardware Integration | Advanced Configuration | Troubleshooting | . ",
    "url": "/ModCube.github.io/tutorials/#table-of-contents",
    
    "relUrl": "/tutorials/#table-of-contents"
  },"113": {
    "doc": "Tutorials",
    "title": "Quick Start",
    "content": "Launch Your First Simulation . After completing the installation, let’s start with a basic simulation: . # Terminal 1: Launch the system roslaunch modcube_mission system.launch model_name:=modcube simulated:=true # Terminal 2: Check system status rostopic echo /modcube/nav_state # Terminal 3: Send a simple command rostopic pub /modcube/controller_command modcube_msgs/ControllerCommand \\ \"header: stamp: now frame_id: 'base_link' mode: 1 setpoint: position: x: 1.0 y: 0.0 z: -1.0 orientation: x: 0.0 y: 0.0 z: 0.0 w: 1.0\" . This will: . | Launch the complete ModCube system in simulation mode | Display the current navigation state | Command the robot to move to position (1, 0, -1) | . Understanding the System Status . # Check running nodes rosnode list # Check available topics rostopic list # Check available services rosservice list # Monitor system health rostopic echo /modcube/alarms . ",
    "url": "/ModCube.github.io/tutorials/#quick-start",
    
    "relUrl": "/tutorials/#quick-start"
  },"114": {
    "doc": "Tutorials",
    "title": "Basic Simulation",
    "content": "Available Simulation Worlds . The ModCube system includes several pre-configured simulation environments: . 1. Base Pool Environment . # Launch base pool simulation roslaunch modcube_sim_worlds base_pool.launch # In another terminal, launch the vehicle roslaunch modcube_mission system.launch model_name:=modcube simulated:=true world:=base_pool . 2. Transdec Environment . # Launch Transdec simulation (more complex environment) roslaunch modcube_sim_worlds transdec.launch # Launch vehicle in Transdec world roslaunch modcube_mission system.launch model_name:=modcube simulated:=true world:=transdec . 3. UMD Test Environment . # Launch UMD simulation roslaunch modcube_sim_worlds umd.launch # Launch vehicle in UMD world roslaunch modcube_mission system.launch model_name:=modcube simulated:=true world:=umd . Simulation Controls . Using Keyboard Teleop . # Launch teleoperation roslaunch modcube_common teleop.launch # Control keys: # W/S: Forward/Backward # A/D: Left/Right # Q/E: Up/Down # I/K: Pitch up/down # J/L: Yaw left/right # U/O: Roll left/right . Using RQT Control Panel . # Launch RQT with custom perspective rqt --perspective-file $(rospack find modcube_common)/config/modcube.perspective . ",
    "url": "/ModCube.github.io/tutorials/#basic-simulation",
    
    "relUrl": "/tutorials/#basic-simulation"
  },"115": {
    "doc": "Tutorials",
    "title": "Control System Tutorial",
    "content": "Understanding the Control Architecture . The ModCube control system uses a hierarchical approach: . | Mission Level: High-level goals and tasks | Guidance Level: Path planning and trajectory generation | Control Level: PID controllers and thrust allocation | Actuation Level: Individual thruster control | . PID Controller Configuration . Viewing Current PID Parameters . # Get current PID parameters rosservice call /modcube/get_pid_params . Tuning PID Parameters . # Set position PID gains rosservice call /modcube/set_pid_params \\ \"position_gains: p: [10.0, 10.0, 10.0] i: [0.1, 0.1, 0.1] d: [5.0, 5.0, 5.0] orientation_gains: p: [20.0, 20.0, 20.0] i: [0.2, 0.2, 0.2] d: [8.0, 8.0, 8.0]\" . Real-time PID Tuning with RQT . # Launch dynamic reconfigure GUI rosrun rqt_reconfigure rqt_reconfigure # Select /modcube/pid_controller for real-time tuning . Thruster Management . Thruster Configuration . # View current thruster configuration rosservice call /modcube/get_thruster_config # Test individual thrusters rostopic pub /modcube/thruster_test modcube_msgs/ThrusterCommand \\ \"header: stamp: now thrusters: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\" . Thrust Allocation Matrix (TAM) . The system uses a 14-thruster configuration. Understanding the TAM: . # Example TAM structure (simplified) # Each row represents [Fx, Fy, Fz, Tx, Ty, Tz] for each thruster TAM = [ [1, 0, 0, 0, 0, 0], # Thruster 0: Forward thrust [0, 1, 0, 0, 0, 0], # Thruster 1: Lateral thrust [0, 0, 1, 0, 0, 0], # Thruster 2: Vertical thrust # ... additional thrusters ] . Control Modes . The system supports multiple control modes: . 1. Position Control . rostopic pub /modcube/controller_command modcube_msgs/ControllerCommand \\ \"header: stamp: now mode: 1 # Position control mode setpoint: position: {x: 2.0, y: 1.0, z: -2.0} orientation: {x: 0, y: 0, z: 0, w: 1}\" . 2. Velocity Control . rostopic pub /modcube/controller_command modcube_msgs/ControllerCommand \\ \"header: stamp: now mode: 2 # Velocity control mode setpoint: linear: {x: 0.5, y: 0.0, z: 0.0} angular: {x: 0, y: 0, z: 0.1}\" . 3. Direct Thrust Control . rostopic pub /modcube/thrust_command modcube_msgs/ThrusterCommand \\ \"header: stamp: now thrusters: [0.1, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\" . ",
    "url": "/ModCube.github.io/tutorials/#control-system-tutorial",
    
    "relUrl": "/tutorials/#control-system-tutorial"
  },"116": {
    "doc": "Tutorials",
    "title": "Mission Planning",
    "content": "Creating Simple Missions . Waypoint Navigation . #!/usr/bin/env python import rospy from modcube_msgs.msg import ControllerCommand from geometry_msgs.msg import Point, Quaternion def navigate_waypoints(): rospy.init_node('waypoint_navigator') pub = rospy.Publisher('/modcube/controller_command', ControllerCommand, queue_size=10) waypoints = [ (0, 0, -1), # Start position (5, 0, -1), # Move forward (5, 5, -1), # Move right (0, 5, -1), # Move back (0, 0, -1), # Return to start ] rate = rospy.Rate(1) # 1 Hz for wp in waypoints: cmd = ControllerCommand() cmd.header.stamp = rospy.Time.now() cmd.mode = 1 # Position control cmd.setpoint.position = Point(wp[0], wp[1], wp[2]) cmd.setpoint.orientation = Quaternion(0, 0, 0, 1) pub.publish(cmd) rospy.loginfo(f\"Moving to waypoint: {wp}\") # Wait for 10 seconds at each waypoint for _ in range(10): rate.sleep() if __name__ == '__main__': navigate_waypoints() . Using the Mission Manager . # Launch mission manager roslaunch modcube_mission mission_manager.launch # Send mission command rosservice call /modcube/mission_control \\ \"command: 'start' mission_type: 'waypoint_navigation' parameters: ['waypoint_file:=/path/to/waypoints.yaml']\" . Advanced Mission Examples . Search Pattern Mission . # search_pattern.yaml mission: type: \"search_pattern\" parameters: search_area: min_x: 0 max_x: 10 min_y: 0 max_y: 10 depth: -2.0 pattern_type: \"lawnmower\" spacing: 2.0 speed: 0.5 . # Execute search pattern rosservice call /modcube/mission_control \\ \"command: 'start' mission_type: 'search_pattern' parameters: ['config_file:=search_pattern.yaml']\" . ",
    "url": "/ModCube.github.io/tutorials/#mission-planning",
    
    "relUrl": "/tutorials/#mission-planning"
  },"117": {
    "doc": "Tutorials",
    "title": "Hardware Integration",
    "content": "IMU Integration . Xsens IMU Setup . # Launch Xsens IMU driver roslaunch modcube_vehicle xsens_imu.launch # Check IMU data rostopic echo /modcube/imu/data # Calibrate IMU (follow manufacturer instructions) rosservice call /modcube/imu/calibrate . IMU Configuration . # imu_config.yaml imu: frame_id: \"imu_link\" frequency: 100 orientation_covariance: [0.01, 0.01, 0.01] angular_velocity_covariance: [0.001, 0.001, 0.001] linear_acceleration_covariance: [0.01, 0.01, 0.01] . DVL Integration . Teledyne DVL Setup . # Launch DVL driver roslaunch modcube_vehicle teledyne_dvl.launch port:=/dev/ttyUSB0 # Check DVL data rostopic echo /modcube/dvl/data # Test DVL communication rosservice call /modcube/dvl/test_communication . Thruster Integration . Pololu Maestro Setup . # Launch thruster controller roslaunch modcube_vehicle actuators.launch # Test thruster response rosservice call /modcube/test_thrusters . Thruster Calibration . #!/usr/bin/env python # thruster_calibration.py import rospy from modcube_msgs.msg import ThrusterCommand def calibrate_thrusters(): pub = rospy.Publisher('/modcube/thrust_command', ThrusterCommand, queue_size=10) # Test each thruster individually for i in range(14): cmd = ThrusterCommand() cmd.header.stamp = rospy.Time.now() cmd.thrusters = [0.0] * 14 cmd.thrusters[i] = 0.1 # 10% thrust pub.publish(cmd) rospy.loginfo(f\"Testing thruster {i}\") rospy.sleep(2) # Stop thruster cmd.thrusters[i] = 0.0 pub.publish(cmd) rospy.sleep(1) . ",
    "url": "/ModCube.github.io/tutorials/#hardware-integration",
    
    "relUrl": "/tutorials/#hardware-integration"
  },"118": {
    "doc": "Tutorials",
    "title": "Advanced Configuration",
    "content": "Custom Vehicle Configuration . Creating a New Vehicle Model . | Create vehicle description: | . &lt;!-- my_vehicle.xacro --&gt; &lt;?xml version=\"1.0\"?&gt; &lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"my_vehicle\"&gt; &lt;!-- Include base ModCube components --&gt; &lt;xacro:include filename=\"$(find modcube_config)/modcube_description/urdf/base.xacro\"/&gt; &lt;!-- Custom thruster configuration --&gt; &lt;xacro:include filename=\"$(find my_vehicle_config)/urdf/thrusters_custom.xacro\"/&gt; &lt;!-- Custom sensor configuration --&gt; &lt;xacro:include filename=\"$(find my_vehicle_config)/urdf/sensors_custom.xacro\"/&gt; &lt;/robot&gt; . | Create launch file: | . &lt;!-- my_vehicle.launch --&gt; &lt;launch&gt; &lt;arg name=\"namespace\" default=\"my_vehicle\"/&gt; &lt;!-- Load vehicle description --&gt; &lt;param name=\"robot_description\" command=\"$(find xacro)/xacro $(find my_vehicle_config)/urdf/my_vehicle.xacro\"/&gt; &lt;!-- Launch vehicle-specific nodes --&gt; &lt;group ns=\"$(arg namespace)\"&gt; &lt;include file=\"$(find modcube_vehicle)/launch/base_vehicle.launch\"&gt; &lt;arg name=\"namespace\" value=\"$(arg namespace)\"/&gt; &lt;/include&gt; &lt;!-- Custom nodes --&gt; &lt;node name=\"custom_sensor\" pkg=\"my_vehicle_drivers\" type=\"custom_sensor_node\"/&gt; &lt;/group&gt; &lt;/launch&gt; . Custom Control Algorithms . Implementing a Custom Controller . #!/usr/bin/env python # custom_controller.py import rospy import numpy as np from modcube_msgs.msg import ControllerCommand, NavState, ThrusterCommand from modcube_common.controllers.controller import BaseController class CustomController(BaseController): def __init__(self): super().__init__() # Custom parameters self.custom_gain = rospy.get_param('~custom_gain', 1.0) # Publishers and subscribers self.thrust_pub = rospy.Publisher('/modcube/thrust_command', ThrusterCommand, queue_size=10) self.nav_sub = rospy.Subscriber('/modcube/nav_state', NavState, self.nav_callback) self.cmd_sub = rospy.Subscriber('/modcube/controller_command', ControllerCommand, self.cmd_callback) self.current_state = None self.current_command = None def nav_callback(self, msg): self.current_state = msg self.update_control() def cmd_callback(self, msg): self.current_command = msg def update_control(self): if self.current_state is None or self.current_command is None: return # Custom control algorithm error = self.compute_error(self.current_state, self.current_command) wrench = self.compute_wrench(error) thrust_cmd = self.allocate_thrust(wrench) self.thrust_pub.publish(thrust_cmd) def compute_error(self, state, command): # Implement custom error computation pass def compute_wrench(self, error): # Implement custom control law pass def allocate_thrust(self, wrench): # Use existing thrust allocation return self.thrust_allocator.allocate(wrench) if __name__ == '__main__': rospy.init_node('custom_controller') controller = CustomController() rospy.spin() . Sensor Fusion Configuration . Custom State Estimator . #!/usr/bin/env python # custom_estimator.py import rospy import numpy as np from sensor_msgs.msg import Imu from modcube_msgs.msg import DVLData, NavState from geometry_msgs.msg import PoseWithCovariance, TwistWithCovariance class CustomStateEstimator: def __init__(self): # Initialize Kalman filter or other estimator self.state = np.zeros(12) # [x, y, z, roll, pitch, yaw, vx, vy, vz, wx, wy, wz] self.covariance = np.eye(12) * 0.1 # Publishers and subscribers self.nav_pub = rospy.Publisher('/modcube/nav_state', NavState, queue_size=10) self.imu_sub = rospy.Subscriber('/modcube/imu/data', Imu, self.imu_callback) self.dvl_sub = rospy.Subscriber('/modcube/dvl/data', DVLData, self.dvl_callback) # Timer for state prediction self.timer = rospy.Timer(rospy.Duration(0.01), self.predict_step) # 100 Hz def predict_step(self, event): # Implement prediction step dt = 0.01 # Update state prediction self.publish_state() def imu_callback(self, msg): # Update with IMU measurements pass def dvl_callback(self, msg): # Update with DVL measurements pass def publish_state(self): nav_msg = NavState() nav_msg.header.stamp = rospy.Time.now() nav_msg.header.frame_id = \"odom\" # Fill in state information nav_msg.pose.pose.position.x = self.state[0] nav_msg.pose.pose.position.y = self.state[1] nav_msg.pose.pose.position.z = self.state[2] # ... fill in remaining fields self.nav_pub.publish(nav_msg) . ",
    "url": "/ModCube.github.io/tutorials/#advanced-configuration",
    
    "relUrl": "/tutorials/#advanced-configuration"
  },"119": {
    "doc": "Tutorials",
    "title": "Troubleshooting",
    "content": "Common Issues and Solutions . 1. Simulation Performance Issues . Problem: Gazebo runs slowly or crashes . Solutions: . # Reduce simulation complexity export GAZEBO_MODEL_PATH=/path/to/simple/models # Use software rendering export LIBGL_ALWAYS_SOFTWARE=1 # Reduce physics update rate # Edit world file: &lt;physics&gt;&lt;real_time_update_rate&gt;100&lt;/real_time_update_rate&gt;&lt;/physics&gt; . 2. Control System Issues . Problem: Robot doesn’t respond to commands . Debugging steps: . # Check if controller is running rosnode list | grep controller # Check command topics rostopic echo /modcube/controller_command # Check thrust output rostopic echo /modcube/thrust_command # Verify thruster allocation rosservice call /modcube/get_thruster_config . 3. Hardware Communication Issues . Problem: Cannot communicate with hardware . Solutions: . # Check device permissions ls -l /dev/ttyUSB* sudo chmod 666 /dev/ttyUSB0 # Check if device is detected dmesg | grep tty # Test serial communication sudo minicom -D /dev/ttyUSB0 -b 115200 . Debug Tools . ROS Debug Commands . # Monitor all topics rostopic list | xargs -I {} rostopic echo {} --noarr # Check node graph rqt_graph # Monitor system resources htop # Check ROS logs roscd &amp;&amp; cd ../log tail -f latest/rosout.log . Gazebo Debug . # Verbose Gazebo output gazebo --verbose # Check Gazebo plugins gzserver --verbose # Monitor Gazebo topics gz topic -l gz topic -e /gazebo/default/physics/contacts . Performance Monitoring . # Monitor ROS node performance rosrun rqt_top rqt_top # Check message frequencies rostopic hz /modcube/nav_state rostopic hz /modcube/controller_command # Monitor network usage iftop . ",
    "url": "/ModCube.github.io/tutorials/#troubleshooting",
    
    "relUrl": "/tutorials/#troubleshooting"
  },"120": {
    "doc": "Tutorials",
    "title": "Advanced Topics",
    "content": "Deep Learning Integration . Object Detection with YOLO . #!/usr/bin/env python # yolo_detector.py import rospy import cv2 import numpy as np from sensor_msgs.msg import Image from cv_bridge import CvBridge from modcube_msgs.msg import DetectedObjects, DetectedObject import torch from ultralytics import YOLO class YOLODetector: def __init__(self): rospy.init_node('yolo_detector') # Load YOLO model self.model = YOLO('yolov8n.pt') # or custom trained model self.bridge = CvBridge() # Publishers and subscribers self.image_sub = rospy.Subscriber('/modcube/camera/image_raw', Image, self.image_callback) self.detection_pub = rospy.Publisher('/modcube/detections', DetectedObjects, queue_size=10) self.debug_pub = rospy.Publisher('/modcube/debug/detection_image', Image, queue_size=1) # Detection parameters self.confidence_threshold = rospy.get_param('~confidence_threshold', 0.5) self.nms_threshold = rospy.get_param('~nms_threshold', 0.4) def image_callback(self, msg): try: cv_image = self.bridge.imgmsg_to_cv2(msg, \"bgr8\") detections = self.detect_objects(cv_image) self.publish_detections(detections, msg.header) except Exception as e: rospy.logerr(f\"Detection error: {e}\") def detect_objects(self, image): # Run YOLO inference results = self.model(image, conf=self.confidence_threshold, iou=self.nms_threshold) detections = [] for result in results: boxes = result.boxes if boxes is not None: for box in boxes: # Extract detection information x1, y1, x2, y2 = box.xyxy[0].cpu().numpy() confidence = box.conf[0].cpu().numpy() class_id = int(box.cls[0].cpu().numpy()) class_name = self.model.names[class_id] detection = { 'bbox': [x1, y1, x2, y2], 'confidence': confidence, 'class_id': class_id, 'class_name': class_name } detections.append(detection) return detections def publish_detections(self, detections, header): msg = DetectedObjects() msg.header = header for det in detections: obj = DetectedObject() obj.class_name = det['class_name'] obj.confidence = det['confidence'] obj.bbox.x = det['bbox'][0] obj.bbox.y = det['bbox'][1] obj.bbox.width = det['bbox'][2] - det['bbox'][0] obj.bbox.height = det['bbox'][3] - det['bbox'][1] msg.objects.append(obj) self.detection_pub.publish(msg) if __name__ == '__main__': detector = YOLODetector() rospy.spin() . Visual SLAM Integration . #!/usr/bin/env python # visual_slam.py import rospy import cv2 import numpy as np from sensor_msgs.msg import Image, CameraInfo from geometry_msgs.msg import PoseStamped from cv_bridge import CvBridge import g2o class VisualSLAM: def __init__(self): rospy.init_node('visual_slam') self.bridge = CvBridge() self.orb = cv2.ORB_create(nfeatures=1000) self.matcher = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True) # Camera parameters self.K = None # Camera intrinsic matrix self.prev_frame = None self.prev_kp = None self.prev_desc = None # SLAM state self.pose = np.eye(4) # Current pose self.trajectory = [] self.map_points = [] # Publishers and subscribers self.image_sub = rospy.Subscriber('/modcube/camera/image_raw', Image, self.image_callback) self.info_sub = rospy.Subscriber('/modcube/camera/camera_info', CameraInfo, self.info_callback) self.pose_pub = rospy.Publisher('/modcube/slam/pose', PoseStamped, queue_size=10) def info_callback(self, msg): # Extract camera intrinsic parameters self.K = np.array(msg.K).reshape(3, 3) def image_callback(self, msg): if self.K is None: return try: cv_image = self.bridge.imgmsg_to_cv2(msg, \"mono8\") self.process_frame(cv_image, msg.header) except Exception as e: rospy.logerr(f\"SLAM error: {e}\") def process_frame(self, frame, header): # Extract ORB features kp, desc = self.orb.detectAndCompute(frame, None) if self.prev_frame is not None and self.prev_desc is not None: # Match features matches = self.matcher.match(self.prev_desc, desc) matches = sorted(matches, key=lambda x: x.distance) if len(matches) &gt; 50: # Minimum matches threshold # Extract matched points pts1 = np.float32([self.prev_kp[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2) pts2 = np.float32([kp[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2) # Estimate motion E, mask = cv2.findEssentialMat(pts1, pts2, self.K, method=cv2.RANSAC) _, R, t, mask = cv2.recoverPose(E, pts1, pts2, self.K) # Update pose T = np.eye(4) T[:3, :3] = R T[:3, 3] = t.flatten() self.pose = self.pose @ T # Triangulate 3D points self.triangulate_points(pts1, pts2, R, t) # Publish pose self.publish_pose(header) # Update previous frame self.prev_frame = frame self.prev_kp = kp self.prev_desc = desc def triangulate_points(self, pts1, pts2, R, t): # Triangulate 3D points from stereo correspondences P1 = self.K @ np.hstack([np.eye(3), np.zeros((3, 1))]) P2 = self.K @ np.hstack([R, t]) points_4d = cv2.triangulatePoints(P1, P2, pts1.T, pts2.T) points_3d = points_4d[:3] / points_4d[3] # Add to map self.map_points.extend(points_3d.T) def publish_pose(self, header): pose_msg = PoseStamped() pose_msg.header = header # Convert pose matrix to ROS message pose_msg.pose.position.x = self.pose[0, 3] pose_msg.pose.position.y = self.pose[1, 3] pose_msg.pose.position.z = self.pose[2, 3] # Convert rotation matrix to quaternion from scipy.spatial.transform import Rotation r = Rotation.from_matrix(self.pose[:3, :3]) q = r.as_quat() pose_msg.pose.orientation.x = q[0] pose_msg.pose.orientation.y = q[1] pose_msg.pose.orientation.z = q[2] pose_msg.pose.orientation.w = q[3] self.pose_pub.publish(pose_msg) if __name__ == '__main__': slam = VisualSLAM() rospy.spin() . Multi-Sensor Fusion with Particle Filter . #!/usr/bin/env python # particle_filter.py import rospy import numpy as np from sensor_msgs.msg import Imu from modcube_msgs.msg import DVLData, NavState from geometry_msgs.msg import PoseWithCovariance class ParticleFilter: def __init__(self, num_particles=1000): rospy.init_node('particle_filter') self.num_particles = num_particles self.particles = np.zeros((num_particles, 6)) # [x, y, z, roll, pitch, yaw] self.weights = np.ones(num_particles) / num_particles # Initialize particles with random distribution self.particles[:, :3] = np.random.normal(0, 1, (num_particles, 3)) self.particles[:, 3:] = np.random.normal(0, 0.1, (num_particles, 3)) # Process and measurement noise self.process_noise = np.diag([0.01, 0.01, 0.01, 0.001, 0.001, 0.001]) self.imu_noise = np.diag([0.1, 0.1, 0.1]) self.dvl_noise = np.diag([0.05, 0.05, 0.05]) # Publishers and subscribers self.nav_pub = rospy.Publisher('/modcube/nav_state_pf', NavState, queue_size=10) self.imu_sub = rospy.Subscriber('/modcube/imu/data', Imu, self.imu_callback) self.dvl_sub = rospy.Subscriber('/modcube/dvl/data', DVLData, self.dvl_callback) # Timer for prediction step self.timer = rospy.Timer(rospy.Duration(0.01), self.predict_step) def predict_step(self, event): # Prediction step: add process noise noise = np.random.multivariate_normal(np.zeros(6), self.process_noise, self.num_particles) self.particles += noise # Normalize angles self.particles[:, 3:] = np.mod(self.particles[:, 3:] + np.pi, 2*np.pi) - np.pi self.publish_state() def imu_callback(self, msg): # Update step with IMU measurements measured_accel = np.array([msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z]) # Compute likelihood for each particle for i in range(self.num_particles): # Predict acceleration based on particle orientation predicted_accel = self.predict_acceleration(self.particles[i]) # Compute likelihood diff = measured_accel - predicted_accel likelihood = np.exp(-0.5 * diff.T @ np.linalg.inv(self.imu_noise) @ diff) self.weights[i] *= likelihood # Normalize weights self.weights /= np.sum(self.weights) # Resample if effective sample size is low if 1.0 / np.sum(self.weights**2) &lt; self.num_particles / 2: self.resample() def dvl_callback(self, msg): # Update step with DVL measurements measured_velocity = np.array([msg.velocity.x, msg.velocity.y, msg.velocity.z]) # Update particles based on DVL measurement for i in range(self.num_particles): # Predict velocity based on particle state predicted_velocity = self.predict_velocity(self.particles[i]) # Compute likelihood diff = measured_velocity - predicted_velocity likelihood = np.exp(-0.5 * diff.T @ np.linalg.inv(self.dvl_noise) @ diff) self.weights[i] *= likelihood # Normalize weights self.weights /= np.sum(self.weights) # Resample if needed if 1.0 / np.sum(self.weights**2) &lt; self.num_particles / 2: self.resample() def predict_acceleration(self, particle): # Predict acceleration based on particle orientation roll, pitch, yaw = particle[3:6] # Gravity vector in body frame R = self.euler_to_rotation_matrix(roll, pitch, yaw) gravity_world = np.array([0, 0, 9.81]) gravity_body = R.T @ gravity_world return gravity_body def predict_velocity(self, particle): # Simple velocity prediction (can be enhanced with motion model) return np.zeros(3) def euler_to_rotation_matrix(self, roll, pitch, yaw): # Convert Euler angles to rotation matrix cr, sr = np.cos(roll), np.sin(roll) cp, sp = np.cos(pitch), np.sin(pitch) cy, sy = np.cos(yaw), np.sin(yaw) R = np.array([ [cy*cp, cy*sp*sr - sy*cr, cy*sp*cr + sy*sr], [sy*cp, sy*sp*sr + cy*cr, sy*sp*cr - cy*sr], [-sp, cp*sr, cp*cr] ]) return R def resample(self): # Systematic resampling indices = np.random.choice(self.num_particles, self.num_particles, p=self.weights) self.particles = self.particles[indices] self.weights = np.ones(self.num_particles) / self.num_particles def publish_state(self): # Compute weighted mean of particles mean_state = np.average(self.particles, weights=self.weights, axis=0) # Compute covariance cov = np.cov(self.particles.T, aweights=self.weights) # Publish navigation state nav_msg = NavState() nav_msg.header.stamp = rospy.Time.now() nav_msg.header.frame_id = \"odom\" nav_msg.pose.pose.position.x = mean_state[0] nav_msg.pose.pose.position.y = mean_state[1] nav_msg.pose.pose.position.z = mean_state[2] # Convert Euler to quaternion from tf.transformations import quaternion_from_euler q = quaternion_from_euler(mean_state[3], mean_state[4], mean_state[5]) nav_msg.pose.pose.orientation.x = q[0] nav_msg.pose.pose.orientation.y = q[1] nav_msg.pose.pose.orientation.z = q[2] nav_msg.pose.pose.orientation.w = q[3] # Set covariance nav_msg.pose.covariance = cov.flatten().tolist() self.nav_pub.publish(nav_msg) if __name__ == '__main__': pf = ParticleFilter() rospy.spin() . Real-Time Optimization . Model Predictive Control (MPC) . #!/usr/bin/env python # mpc_controller.py import rospy import numpy as np import cvxpy as cp from modcube_msgs.msg import ControllerCommand, NavState, ThrusterCommand from geometry_msgs.msg import Wrench class MPCController: def __init__(self): rospy.init_node('mpc_controller') # MPC parameters self.horizon = 10 # Prediction horizon self.dt = 0.1 # Time step # State and input dimensions self.nx = 12 # [x, y, z, roll, pitch, yaw, vx, vy, vz, wx, wy, wz] self.nu = 6 # [Fx, Fy, Fz, Tx, Ty, Tz] # Vehicle parameters self.mass = 50.0 # kg self.inertia = np.diag([10.0, 10.0, 15.0]) # kg*m^2 # Cost matrices self.Q = np.diag([100, 100, 100, 10, 10, 10, 1, 1, 1, 1, 1, 1]) # State cost self.R = np.diag([1, 1, 1, 1, 1, 1]) # Input cost self.Qf = 10 * self.Q # Terminal cost # Constraints self.u_max = np.array([200, 200, 200, 50, 50, 50]) # Max forces/torques self.u_min = -self.u_max # Current state and reference self.current_state = np.zeros(self.nx) self.reference = np.zeros(self.nx) # Publishers and subscribers self.wrench_pub = rospy.Publisher('/modcube/wrench_command', Wrench, queue_size=10) self.nav_sub = rospy.Subscriber('/modcube/nav_state', NavState, self.nav_callback) self.cmd_sub = rospy.Subscriber('/modcube/controller_command', ControllerCommand, self.cmd_callback) # Control timer self.timer = rospy.Timer(rospy.Duration(self.dt), self.control_step) def nav_callback(self, msg): # Extract state from navigation message self.current_state[0] = msg.pose.pose.position.x self.current_state[1] = msg.pose.pose.position.y self.current_state[2] = msg.pose.pose.position.z # Convert quaternion to Euler angles from tf.transformations import euler_from_quaternion q = [msg.pose.pose.orientation.x, msg.pose.pose.orientation.y, msg.pose.pose.orientation.z, msg.pose.pose.orientation.w] roll, pitch, yaw = euler_from_quaternion(q) self.current_state[3:6] = [roll, pitch, yaw] self.current_state[6] = msg.twist.twist.linear.x self.current_state[7] = msg.twist.twist.linear.y self.current_state[8] = msg.twist.twist.linear.z self.current_state[9] = msg.twist.twist.angular.x self.current_state[10] = msg.twist.twist.angular.y self.current_state[11] = msg.twist.twist.angular.z def cmd_callback(self, msg): # Extract reference from command self.reference[0] = msg.setpoint.position.x self.reference[1] = msg.setpoint.position.y self.reference[2] = msg.setpoint.position.z # Convert quaternion to Euler angles from tf.transformations import euler_from_quaternion q = [msg.setpoint.orientation.x, msg.setpoint.orientation.y, msg.setpoint.orientation.z, msg.setpoint.orientation.w] roll, pitch, yaw = euler_from_quaternion(q) self.reference[3:6] = [roll, pitch, yaw] # Zero velocity reference self.reference[6:] = 0 def control_step(self, event): # Solve MPC optimization problem u_opt = self.solve_mpc() if u_opt is not None: # Publish control command wrench_msg = Wrench() wrench_msg.force.x = u_opt[0] wrench_msg.force.y = u_opt[1] wrench_msg.force.z = u_opt[2] wrench_msg.torque.x = u_opt[3] wrench_msg.torque.y = u_opt[4] wrench_msg.torque.z = u_opt[5] self.wrench_pub.publish(wrench_msg) def solve_mpc(self): # Define optimization variables x = cp.Variable((self.nx, self.horizon + 1)) u = cp.Variable((self.nu, self.horizon)) # Cost function cost = 0 constraints = [] # Initial condition constraints.append(x[:, 0] == self.current_state) for k in range(self.horizon): # Stage cost cost += cp.quad_form(x[:, k] - self.reference, self.Q) cost += cp.quad_form(u[:, k], self.R) # Dynamics constraints x_next = self.dynamics(x[:, k], u[:, k]) constraints.append(x[:, k + 1] == x_next) # Input constraints constraints.append(u[:, k] &gt;= self.u_min) constraints.append(u[:, k] &lt;= self.u_max) # Terminal cost cost += cp.quad_form(x[:, self.horizon] - self.reference, self.Qf) # Solve optimization problem problem = cp.Problem(cp.Minimize(cost), constraints) try: problem.solve(solver=cp.OSQP, verbose=False) if problem.status == cp.OPTIMAL: return u[:, 0].value else: rospy.logwarn(f\"MPC solver status: {problem.status}\") return None except Exception as e: rospy.logerr(f\"MPC solver error: {e}\") return None def dynamics(self, x, u): # Simplified 6-DOF dynamics pos = x[:3] euler = x[3:6] vel_linear = x[6:9] vel_angular = x[9:12] force = u[:3] torque = u[3:6] # Linear acceleration accel_linear = force / self.mass # Angular acceleration accel_angular = np.linalg.inv(self.inertia) @ torque # Euler angle rates (simplified) euler_rates = vel_angular # State derivative x_dot = cp.vstack([ vel_linear, euler_rates, accel_linear, accel_angular ]) # Euler integration return x + self.dt * x_dot if __name__ == '__main__': mpc = MPCController() rospy.spin() . ",
    "url": "/ModCube.github.io/tutorials/#advanced-topics",
    
    "relUrl": "/tutorials/#advanced-topics"
  },"121": {
    "doc": "Tutorials",
    "title": "Next Steps",
    "content": "After completing these tutorials: . | Explore Examples for more complex scenarios | Review API Documentation for development | Contribute to the project by submitting improvements | Join the community for support and collaboration | . For more advanced topics, consider: . | Multi-vehicle coordination | Machine learning integration | Custom sensor development | Real-time optimization techniques | . ",
    "url": "/ModCube.github.io/tutorials/#next-steps",
    
    "relUrl": "/tutorials/#next-steps"
  }
}
